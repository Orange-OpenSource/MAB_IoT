#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <math.h>
#include <float.h>
#include <dos.h>
#include "type.h"
#define PI 3.14159265

/** nodes using ADR algorithm to select sf and TP
*/
void exploitADR()
{
    printf("************************_____________ ADR ___________****************************\n");

    FILE *f1;
    FILE *f2;

    int **lossOfarms;
    lossOfarms=(int**)malloc(sizeof(int*)*6);
    for(int i=0;i<6;i++)
    {
        lossOfarms[i]=(int*)malloc(sizeof(int)*5);
        for(int j=0;j<5;j++)
            lossOfarms[i][j]=0;
    }


    while(nbPkts<T)
    {
        if((nbPkts) % (T/TimeDisplay)==0 ) printf("%d packets are already sent\n",nbPkts);
        for(int n=0;n<N;n++)
        {
            if(node[n].pr >= RAND_R(1.0))
            {
                ///background nodes
                if(n<N1)
                    {if(backgroundN!=5) node[n].arm =selectArm(n);
                    if(backgroundN==5)
                        {if(node[n].last_sinr[19]!=-1.0 )
                            ADR(n);
                         node[n].arm=node[n].ind_sf;
                        }
                    }

                node[n].isPlaying=1;

                ///play ADR
                if(n>=N1)
                {
                    if(node[n].last_sinr[19]!=-1.0 )
                        ADR(n);

                    node[n].arm=node[n].ind_sf;
                    arms[node[n].ind_sf][(int) node[n].tx/3]++;
                    nPlaysbyarm[node[n].arm]++;
                    global_plays++;
                    global_energy=global_energy+energy(n);
                }

                node[n].nb_plays++;

                float rn=0.0;
                while(rn==0)rn=RAND_R(1.0); //nonzero to avoid infinity values after division
                node[n].rayleigh=-1.0*log(rn);
                node[n].PL=log2lin(pathLoss(n)+P.shadowing*randn());
                node[n].RSSI=log2lin(node[n].tx)*node[n].rayleigh/node[n].PL;
                node[n].energy=node[n].energy+energy(n);

                node[n].nb_sf[node[n].ind_sf]++;
                nb_sf[node[n].ind_sf]++;
            }
            else node[n].isPlaying=0;
        }


            ///Collisions Study
            for(int n=0;n<N;n++)
            {
                if(node[n].isPlaying)
                {
                    ///success or failure of transmission
                    int y=Tr_success(n);
                    int k=node[n].arm;
                    node[n].B[k].mu=(float)y/(float)node[n].B[k].tk+(float)(node[n].B[k].tk-1)/(float)node[n].B[k].tk*node[n].B[k].mu;

                    ///background nodes following ADR
                    if(n<N1 && backgroundN==5)
                    {
                        updateSINR(n);
                        if(y==1)
                            {node[n].last_sinr[node[n].indx]=node[n].SINR;
                            node[n].indx++;
                            node[n].pr=node[n].p;
                            node[n].cons_coll=0;
                            }
                        if(y==0) node[n].cons_coll++;
                        if(node[n].cons_coll==retransmit)
                            node[n].cons_coll=0;
                        if(node[n].cons_coll==3 || node[n].cons_coll==5 || node[n].cons_coll==7)
                            {node[n].ind_sf++;
                            if(node[n].ind_sf>5)node[n].ind_sf=5;
                            }
                    }

                    if(n>=N1)
                        {updateSINR(n);
                        if(y==1)
                            {node[n].last_sinr[node[n].indx]=node[n].SINR;
                            node[n].indx++;
                            node[n].pr=node[n].p;
                            }
                        }

                    if(y==0&& n>=N1)
                        node[n].cons_coll++;

                    float rw=getReward(n,y==0,node[n].cons_coll+1);
                    if(n>=N1)
                        {global_rewards=global_rewards+rw;
                         rewardAvgs[node[n].ind_sf][(int) node[n].tx/3]=rewardAvgs[node[n].ind_sf][(int) node[n].tx/3]+rw;
                        }

                    if(y==1&& n>=N1)
                        {
                        node[n].pr=node[n].p;
                        nbPkts++;
                        node[n].cons_coll=0;
                        global_success++;
                        node[n].nb_success++;
                        }
                    node[n].nb_pkts++;

                    if(node[n].cons_coll==retransmit&& n>=N1)
                        {node[n].cons_coll=0;
                        node[n].pr=node[n].p;

                        nbPkts++;
                        losArms[node[n].ind_sf][(int) node[n].tx/3]++;
                        totally_lost[dr]++;
                        lossOfarms[node[n].ind_sf][(int) node[n].tx/3]++;
                        }

                    if(y==0&& n>=N1)
                        {
                         ///probability increased due to loss
                         node[n].pr=node[n].p*8;
                         ///consecutive collisions lead to sf increase
                         if(node[n].cons_coll==3 || node[n].cons_coll==5 || node[n].cons_coll==7)
                            {
                            node[n].ind_sf++;
                            if(node[n].ind_sf>5)node[n].ind_sf=5;
                            }
                        }
                }
            }

        slotEnd();
        slot++;
    }

printf("energy=%f, lost packets=%d, received packets=%d, pkts sent=%d, all plays=%d, pdr=%f\n",global_energy,totally_lost[dr],global_success,nbPkts,global_plays,(float)global_success/global_plays);

}







