
#ifndef TYPE_H_
#define TYPE_H_

#endif /*TYPE_H_*/

#define Pi 3.141592653
#define e 2.718281828


int verbose; // =1 Active les affichages
int TimeDisplay; // Délai en itérations entre deux affichages
int Draws;	// Nombre de tirages
int K; // nombre d'actions
int M; //number of best arms
int T; // Nombre max d'itérations
int N; // Nombre de joueurs
int tao;
float p1;
float pN;
float col;
int comm; // whether the algorithms are run with communication or not
float delta; // probabilité totale de se tromper
float epsilon; // erreur d'approximation maximum
double eta; // probabilité de se tromper d'un joueur
int greedy;
int oracle; // action oracle
float *mu;
int *Action; // Tableau des actions
int Algorithm; //1 DME 0 ME
float *Arm; // Probabilité de récompense de chaque bras
int NbActions; //Nombre d'actions restantes
int reset;
int exploit;
int* M_best;
int* globalT;
float* globalR;
int* globalS;
FILE *globalFic;
FILE *myfile;
FILE *diffFile;
int countt;
char nom_globalFic[256];
float randX;
float playDiff;
float* activeRates;
float* finalEstimation;
float** estimations;
int* rateCost;
int* sampleComplexity;
int* estimationCost;
float epsilon2;
int* duration;
int* totalTime;
int* totalCost;
float* muMin;
float* muMax;
float* Pmin;
float* Pmax;
int* loss;
float** avg_arm;
double* X;
float Xmin;
float Xmax;
float** col_arm;
float** los_arm;
char nom_fic1[256],nom_fic2[256],nom_fic3[256],nom_fic4[256],nom_fic5[256],nom_fic6[256],nom_fic7[256],nom_fic8[256],nom_fic9[256],nom_fic10[256],nom_fic11[256],nom_fic12[256],nom_fic13[256],nom_fic15[256],nom_fic16[256],nom_fic17[256],nom_fic18[256],nom_fic19[256],nom_fic20[256],nom_fic21[256],nom_fic22[256],nom_fic23[256],nom_fic24[256],nom_fic25[256],nom_fic26[256],nom_fic27[256];
FILE *fic;
FILE *fic2;
float* plPerArm;
int* armsPlays;
float realReward;
float gain[2][8]; // channel gain when the problem is the joint channel selection and power control
float alpha; //price factor
float* D;
float**D_k;
int* nb_plays;
float* global_mu;
int counter0;
int** playsPerPL;
float** playersMeans;
float** fairness;
float** wEXP;
float** pEXP;
float gamma;



struct Bandit {
	float mu; // moyenne empirique
	float stdd; //standard deviation
	int tk; // nombre de tirages du bras;
	double B; // Index UCB
	double beta;
	double U;
	double L;
	int notified;

	float UCB;
	float LCB;

	float var;
	float* reward;
};


struct Player {
	int n;
	float p;
	float pr;
	float epsilon;
	float delta;
	int *A;
	int k;
	struct Bandit *B;
	int NbAction;
	int t;

	float UCB;
	float LCB;
	int U;
	int L;

    int* armsSeq;
    float* rewardsSeq;
    float* avgSeq;

	float *Arm;
	int *bestM;
	int armToPlay;

	int ack_ActiveRate;
	int finishEstimating;
	int T_k;
	int estimationsSent;
    int lastPlayedArm;
	int* nbPlayArms;

};

struct Player * Player;
int *collisions;
int *totalCollisions;
int *plays;
int *samples;
int **coll;
int *mistakes;

float** mu_pi;
float** average_mu;
float** collRate;
float* Rewards;
int dr;
float* playersRewards;

int InitNetwork(char *filename); // Initialise le Online Decision Problem à partir du fichier de paramètres
void InitAction();
void InitBandit(struct Bandit *B);
void InitPlayers();


void GenerateProblem_10();
void GenerateProblem_0();
void GenerateProblem_1();
void GenerateProblem_01();
// K bras Bernouilli avec proba différentes


float GetReward(int k,int p,int i);
// retourne la récompense du bras k

float RAND_R(float x);	// Renvoie un nombre aléatoire entre 0 et x
int Card(int * AD); // Renvoie le cardinal de AD[i]=1
int RoundRobin(int k, int *A); // Joue à tour de rôle les actions possibles

float find_U(int n, int k);
float find_L(int n, int k);
float getU(float avg, float level);
float getL(float avg, float level);
float absolute(float x);
void updateUCB1 (int n, int t);

int isPlaying(int n, float x);
int leastPlayed(int n, int p);
int* sortPlayers();
int* sortPlayersReverse();
void StartExploit();
//time_t timeT;
float expReward();
float expPDR();
int selectChannel();
int slowPl();
void find_epsilon2();
void initialize_T_k();
int playerFinishEstimating(int n);
int playerFinishEstimating1(int n);
int finishEstimating();
int allisDone();
int activeRatesKnown();
float collisionRate(int n);
void findFinalEstimation();
void leftPlayers();
void initialize_SelfishT_k();
int SelfishfinishEstimating();
int selfishPlayerFinishEstimating(int n);
float expectedSuccessRate(int n);
void initializeActiveRates();
float nbPlays();
float nbCollisions();
int testArms(int n);
int fastPl();
int playArm_UCB (int n);
int finish(int n);
int PlayRoundRobin (int n);
void findT_star();
int enoughEstimations();
void initFiles(char *nom_fichier);
float expectedFair(int minP, int maxP);
void findM_best();
int playM_bestUniformly();
void updateM_UCB1 (int n, int t);
int playArm_UCB_M (int n);
int finish_M(int n);
float expectedCol(int k);
void find_bestM(int n);
int isMbest(int n, int k);
int playMbest(int n);
int uniformPlay();
int ForcedFinishEstimating();
void p_exp3(int n);
int drawArm_exp3(int n);
void update_wEXP(int n ,float y);
void dorg();
void dofg();


