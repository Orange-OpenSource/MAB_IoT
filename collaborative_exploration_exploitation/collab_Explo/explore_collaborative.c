#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <math.h>
#include <float.h>
#include "type.h"

/** the collaborative exploration algorithm
*/
void collaborativeAlgo(char *nom_fichier)
{
        int k,n,play,yes=0;
        float y;
        int count=0;
        int count1=0;int colll=0;int pll=0;int initial=0;int initialP=0;

        while(enoughEstimations()==0)
            {if(testFinishRequiredNb()) if(totalTime[dr]==0)totalTime[dr]=duration[dr];
             duration[dr]=duration[dr]+1;
             globalT[dr]=globalT[dr]+1;
             if(globalT[dr]%(T/TimeDisplay)==0)fprintf(globalFic,"(%d,%f)\n", globalT[dr],(float)globalR[dr]/globalS[dr]);
             count=0;
             if(duration[dr]%TimeDisplay==0)
                {colll=collisions[dr]-initial;
                initial=collisions[dr];
                pll=plays[dr]-initialP;
                initialP=plays[dr];
                }
             for (n=0; n<N; n++)
                {play=0;
                //sending active rate or estimating
                float x=RAND_R(1.0);
                play=isPlaying(n,x);
                if(play==1){Player[n].k=PlayRoundRobin (n);
                            k=Player[n].k;
                            globalS[dr]=globalS[dr]+1;
                            plays[dr]=plays[dr]+1;//cou nt++;
                            Player[n].B[k].tk=Player[n].B[k].tk+1;
                            Player[n].t=Player[n].t+1;
                            if(N==1280 && n==1279 ) printf("Player[%d].B[%d].tk=%d, played %d times expected %f, where t=%d\n",n,k,Player[n].B[k].tk,Player[n].t,Player[n].pr*globalT[dr], globalT[dr] );
                            }
                if( play==1&& playerFinishEstimating(n)==0)
                    {

                    if(activeRates[n]!=Player[n].pr)rateCost[dr]=rateCost[dr]+1;
                    sampleComplexity[dr]=sampleComplexity[dr]+1;
                    }

                // sending estimations or normal play after finish estimating
                else if (play==1 && activeRates[n]==Player[n].pr && playerFinishEstimating(n)==1 && Player[n].finishEstimating==1)
                    {
                     if(Player[n].estimationsSent<1)
                        {estimationCost[dr]=estimationCost[dr]+1;}
                    }
                if(play==0) Player[n].k=-1;
                }
            for (n=0; n<N; n++)
            {

                k=Player[n].k;
                //reward gained by player n
                if(Player[n].k!=-1) {
                    y=GetReward(Player[n].k,n,dr);
                    if(y==0.0)totalCollisions[dr]=totalCollisions[dr]+1;
                    else Player[n].p=Player[n].pr;

                    globalR[dr]=globalR[dr]+y;
                    avg_arm[dr][k]=avg_arm[dr][k]+(float)y;
                    Player[n].B[k].mu=(float)y/(float )Player[n].B[k].tk+(float)(Player[n].B[k].tk-1)/(float)Player[n].B[k].tk*Player[n].B[k].mu;
                    Rewards[dr]=Rewards[dr]+y;
                    playersRewards[n]=playersRewards[n]+y;
                    if(activeRates[n]!=Player[n].pr )
                        {
                            if(y==1.0)
                            {activeRates[n]=Player[n].pr;
                             if(activeRatesKnown()==1&& yes==0){printf("active rates after %d samples at t=%d with player %d,\n",sampleComplexity[dr],duration[dr],n );yes=1;
                                                            }
                             }
                        }

                    if ( playerFinishEstimating(n)==1 && Player[n].finishEstimating==1 && Player[n].estimationsSent<1 )
                            {if(y==1.0) { Player[n].estimationsSent=Player[n].estimationsSent+1;
                                        if(Player[n].estimationsSent>=1 ){
                                            count1++;
                                            for(int nn=0;nn<K;nn++)
                                            Player[n].nbPlayArms[nn]=Player[n].B[nn].tk;
                                            }
                                        printf("player %d succeeds to send its estimations at time %d__%d\n",n,globalT[dr],Player[n].estimationsSent);
                                    }
                            if(y==0.0)printf("player %d fails to send its estimations********************\n",n);
                            }
                    for(int pl=0;pl<N;pl++)
                    {
                        if (playerFinishEstimating(pl)==1 && Player[pl].finishEstimating==0)
                            {
                                if(finishEstimating()) printf("players finish estimating at time %d with player %d, who send? %d \n", duration[dr],n,Player[pl].estimationsSent);
                                for(int arm=0;arm<K;arm++)
                                    estimations[pl][arm]=Player[pl].B[arm].mu/collisionRate(pl);
                                Player[pl].finishEstimating=1;
                                printf("player %d finished estimating at time %d \n",pl,globalT[dr]);
                            }
                    }

                }
            }
            }
            printf("draw=%d, ratecost=%d and sample complexity =%d estimationCost=%d duration=%d totaltime=%d totalsamples=%d coll=%d, colAvg=%f\n",dr, rateCost[dr],sampleComplexity[dr],estimationCost[dr],duration[dr],totalTime[dr],plays[dr],collisions[dr],(float)collisions[dr]/plays[dr]);

            findFinalEstimation();

            for(int j=0;j<K;j++)
            {
                printf("estimation[%d]=%f(%f)\n",j,finalEstimation[j],Arm[j]);
            }

        samples[dr]=plays[dr];
        mu_pi[dr][0]=(float)Rewards[dr]/duration[dr];
        average_mu[dr][0]=(float)Rewards[dr]/plays[dr];
        collRate[dr][0]=(float)collisions[dr]/plays[dr];

}







