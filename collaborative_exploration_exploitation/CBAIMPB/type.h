#ifndef TYPE_H_
#define TYPE_H_

#endif /*TYPE_H_*/

#define Pi 3.141592653
#define e 2.718281828


int verbose; // =1 Active les affichages
int TimeDisplay; // Délai en itérations entre deux affichages
int Draws;	// Nombre de tirages
int K; // nombre d'actions
int M; //number of best arms
int T; // Nombre max d'itérations
int N; // Nombre de joueurs
int comm; // whether the algorithms are run with communication or not
float delta; // probabilité totale de se tromper
float epsilon; // erreur d'approximation maximum
double eta; // probabilité de se tromper d'un joueur
int oracle; // action oracle
float *mu;
int *Action; // Tableau des actions
int *globalSelected;
int *globalDiscarded;
int Algorithm; //1 DME 0 ME
float *Arm; // Probabilité de récompense de chaque bras
int NbActions; //Nombre d'actions restantes
int reset;
float** average_mu;
float* Rewards;
int *plays;
float** collRate;
int* loss;
float* muMin;
float* muMax;
float** playersMeans;
float* playersRewards;
int* M_best;
int* duration;
float p1;
float pN;
float col;
FILE *fic;
FILE *fic2;
char nom_fic4[256],nom_fic5[256],nom_fic6[256],nom_fic7[256],nom_fic8[256],nom_fic9[256],nom_fic10[256],nom_fic11[256],nom_fic12[256],nom_fic13[256],nom_fic15[256],nom_fic16[256],nom_fic17[256],nom_fic18[256],nom_fic19[256],nom_fic20[256],nom_fic21[256],nom_fic22[256],nom_fic23[256],nom_fic24[256],nom_fic25[256],nom_fic26[256],nom_fic27[256];


float gain[2][8]; // channel gain when the problem is the joint channel selection and power control
float alpha; //price factor

int* nb_plays;
float* global_mu;

struct Bandit {
	float mu; // moyenne empirique
	float stdd; //standard deviation
	int tk; // nombre de tirages du bras;
	double B; // Index UCB
	double beta;
	double U;
	double L;
	int notified;

	float UCB;
	float LCB;

	float var;
	float* reward;
};


struct Player {
	int n; // Numéro de joueur
	float p; // probabilité du joueur
	float epsilon;
	float eta;
	float delta;
	int *A; // Actions du joueur
	int k; // action courante du joueur
	struct Bandit *B; // bandit du joueur
	int NbAction; // Nombre d'actions restantes du joueur
	int t; // Nombre de tirages du joueur

	int *nonOptimals;
	float UCB;
	float LCB;
	int phase1;
	int stopCom;

	//used in Racing algorithm
	int *selected;
	int *discarded;

	float *Arm; // expected regret of arms with channel selection and power control
};

struct Player * Player;
int **Lambda; // Lambda[n*NbBin][k]=1 lorsque le joueur n*NbBin a demandé la suppression de l'action k
int **omiga;
float **Logs; // Regret par temps
int *SampleC; // Complexité d'échantillonnage
int *collisions;
int *plays;

int InitNetwork(char *filename); // Initialise le Online Decision Problem à partir du fichier de paramètres
int PlayNetwork11(char *nomfichier);	// Boucle DME
int PlayNetwork10(char *nomfichier);	// Boucle DME
int PlayNetwork20(char *nomfichier);	// Boucle ME
int PlayNetwork21(char *nom_fichier); // Boucle DSE
int PlayNetwork30(char *nom_fichier); // Boucle SE
int PlayNetwork31(char *nom_fichier);
int PlayNetwork4(char *nom_fichier); // Boucle DUGapEc
int PlayNetwork5(char *nom_fichier); // Boucle UGapEc

void GenerateProblem_10();
void GenerateProblem_0();
void GenerateProblem_1();
void GenerateProblem_01();
// K bras Bernouilli avec proba différentes


float GetReward(int k,int p,int i);
// retourne la récompense du bras k

float RAND_R(float x);	// Renvoie un nombre aléatoire entre 0 et x
int Card(int * AD); // Renvoie le cardinal de AD[i]=1
int RoundRobin(int k, int *A); // Joue à tour de rôle les actions possibles

void findM_best();
int playM_bestUniformly();

