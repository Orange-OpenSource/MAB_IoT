
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include <string.h>
#include "type.h"

int *P;

/**returns random number between 0 and x*/
float RAND_R(float x)
{
	return (float)rand()/(double)(RAND_MAX-1.0)*x;
}



int Card(int * AD)
// Renvoie le cardinal de AD[i]=1
{
	int i,s;

	s=0;
	for (i=0;i<K;i++) {
		if (AD[i]==1) s++;
	}
	return s;
}

/** find the single remaining action*/
int* RemainingActions(int * AD)
{   int i,j=0;
    int* max;
	max=(int*)malloc(sizeof(int)*(M));

	for (i=0;i<K;i++) {
		if (AD[i]==1)
        {max[j]=i;
        j++;
        }
	}
	return max;
}


int RoundRobin(int k, int *A)
// Joue à tour de rôle les actions possibles
{
	int i=k+1;

	if (i >= K) i=0;

	while (i<K && A[i] != 1) {
		i++;
		if (i==K) i=0;
	}
    //printf("i=%d\n",i);
	return i;
}

/**choose an arm randomly in A*/
int RandomChoice(int *A)
{
	int i,k;
	float a;
	int *arms;
	int sum=0;
	int s=0;
    for(int j=0;j<K;j++)
        if(A[j]==1) sum++;

    arms=(int *)malloc(sum*sizeof(int));
    for(int j=0;j<K;j++)
        if(A[j]==1) {arms[s]=j;s++; }
	a=floor(RAND_R((float)(sum)));
	while(a>=sum)a=floor(RAND_R((float)(sum)));
	k=(int)a;
    i=arms[k];
	return i;
}

/**return the number arm k is played
*/
int played(int k)
{
    int sum=0;
    for(int i=0;i<N;i++)
        sum=sum+Player[i].B[k].tk;
    return sum;
}

void InitAction()
// Initialise le tableau d'actions
{
	int i;

	for (i=0;i<K;i++) Action[i]=1;
	for (i=0;i<K;i++) globalDiscarded[i]=0;
	for (i=0;i<K;i++) globalSelected[i]=0;

}

void InitBandit(struct Bandit *B)
// Initialise la structure Bras
{
	int i;

	for (i=0;i<K;i++) {
			B[i].mu=0.0;
			B[i].tk=0;
			B[i].B=RAND_MAX;
			B[i].UCB=900.0;
			B[i].LCB=-900.0;
			B[i].var=0; //variance
			B[i].reward=(float*)malloc(sizeof(float)*1);
			B[i].notified=0;
		}

}

void InitPlayers()
// Initialise la structure Players
{
	int i,j;

	for (i=0;i<N;i++) {
			//Player[i].p=1.0/(float)N;
			//if(i<N/20)Player[i].p= 0.8; else Player[i].p=0.1;
			InitBandit(Player[i].B);
			Player[i].epsilon=epsilon/4.0;
			Player[i].eta=eta/2;
			Player[i].delta=delta/2;
			for (j=0;j<K;j++) {Player[i].A[j]=1;}
			for (j=0;j<K-M;j++) {Player[i].nonOptimals[j]=-1;}
			for (j=0;j<M;j++) {Player[i].selected[j]=-1;}
			for (j=0;j<K-M;j++) {Player[i].discarded[j]=-1;}
			Player[i].k=0;
			Player[i].NbAction=K;
			Player[i].t=0;
			Player[i].phase1=0;
			Player[i].stopCom=0;
			playersRewards[i]=0.0;

	}
}

/**returns players' distribution
*/
void initializeActiveRates()
{
    p1=(1-exp(log(1-col)/(1280-1)))*10;
    pN=p1/4;
    p1=(2*p1-pN);
    printf("pN=%f\n",pN);
    float sump=0.0;
    printf("p1=%f\n",p1);
	int n;
    float x=(p1-pN)/(N-1);
    float y=pN;
	for (n=0;n<N;n++) {
		Player[n].p=y;
		sump=sump+Player[n].p;
		y=y+x;
	}

    printf("sump=%f\n",sump);

}

/**returns 1 if the two vectors A and B are identical
*/
int sameVector(int *A, int *B, int n)
{
    for(int i=0; i<n; i++)
        if(A[i]!=B[i]) return 0;
    return 1;
}

void InitServer()
// Initialise le serveur
{
	int i,j;

	for (i=0;i<N;i++) {
		for (j=0;j<K;j++) Lambda[i][j]=0;
	}
	for (i=0;i<N;i++) {
		for (j=0;j<K;j++) omiga[i][j]=0;
	}
	for(i=0;i<K;i++)
        {global_mu[i]=0.0; nb_plays[i]=0;}
}

/**retruns 1 if plaer n is playing
*/
int isPlaying(int n)
{
    float p=Player[n].p;
    float x=RAND_R(1.0);

    if(x<=p)
        return 1;
    return 0;
}

void CallServer()
// Test la suppression des actions suite à la modification du player n
{
	int i,j,counter,k;
	if(Card(Action)!=M)
    {
    // eliminate arms that enough players want to eliminate
    for (j=0;j<K;j++) {

        //count the number of players that would like to eliminate arm j
		counter=0;
		for (i=0;i<N;i++) {
                counter=counter+Lambda[i][j];
			//if (Lambda[i][j] == 1) counter++;
		}
        printf("counter=%d,needed=%d arm=%d played=%d mu=%f********************************************************\n", counter,(int)ceil(log(delta)/log(eta) ),j,nb_plays[j],global_mu[j]);
        // enough players wants to eliminate arm k
		if (counter >= (int)ceil(log(delta)/log(eta) )) {
			for (i=0;i<N;i++) {
				if (Card(Player[i].A) > M && Lambda[i][j] == 0) {
					Player[i].A[j]=0;
				}
				if (Card(Player[i].A) == M && Lambda[i][j] == 0) {
					k=RoundRobin(j,Player[i].A);
					Player[i].A[j]=0;
					Player[i].A[k]=1;

				}
			}
			if (Card(Action) > M) {Action[j]=0;}
		}


	}
	}

    if (Card(Action) == M) {

		for (j=0;j<K;j++)
			for (i=0;i<N;i++) {
				Player[i].A[j]=Action[j];
				if (Action[j]==1) Lambda[i][j]=0;
				else Lambda[i][j]=1;
			}
        }


}

void ServerCall()
// Test la suppression des actions suite à la modification du player n
{
	int i,j,counter,k;
	if(Card(Action)!=M)
    {
    // eliminate arms that enough players want to eliminate
    for (j=0;j<K;j++) {

        //count the number of players that would like to eliminate arm j
		counter=0;
		for (i=0;i<N;i++) {
			if (Lambda[i][j] == 1) counter++;
		}
		if (counter >= (int)ceil(log(delta)/log(eta) )) {

			for (i=0;i<N;i++) {
				if (Card(Player[i].A) > M && Lambda[i][j] == 0) {
					Lambda[i][j]=1;
					Player[i].A[j]=0;
				}
				if (Card(Player[i].A) == M && Lambda[i][j] == 0) {

					k=RoundRobin(j,Player[i].A);
					Lambda[i][j]=1;
					Player[i].A[j]=0;
					Player[i].A[k]=1;
					Lambda[i][k]=0;

				}
			}
			if (Card(Action) > M) {Action[j]=0;}
		}


	}
	}

    if (Card(Action) == M) {

		for (j=0;j<K;j++)
			for (i=0;i<N;i++) {
				Player[i].A[j]=Action[j];
				if (Action[j]==1) Lambda[i][j]=0;
				else Lambda[i][j]=1;
			}
        }


}


void initFiles(char *nom_fichier)
{

	strcpy(nom_fic5,nom_fichier);
	strcat(nom_fic5,"_sampleComplexity.txt");

	strcpy(nom_fic6,nom_fichier);
	strcat(nom_fic6,"_TotalDuration.txt");

	strcpy(nom_fic9,nom_fichier);
	strcat(nom_fic9,"_fairnessLevel.txt");

	strcpy(nom_fic10,nom_fichier);
	strcat(nom_fic10,"_meanReward.txt");

	strcpy(nom_fic11,nom_fichier);
	strcat(nom_fic11,"_internalCollisionRate.txt");

	strcpy(nom_fic18,nom_fichier);
	strcat(nom_fic18,"_ExtrCollisionRate.txt");

}

void PlotCurve(char *nom_fichier)
{
	FILE *fic;
	int i,s,S;
	float m,ecart;
	char nom_fic1[256],nom_fic2[256],nom_fic3[256];


	/*****************************************************/

	fic=fopen(nom_fic18,"a");
	ecart=0.0;
	m=0.0;
	for (i=0;i<Draws;i++) {
		m=m+(float)loss[i]/plays[i];
	}
	m=m/(float)Draws;
	for(i=0;i<Draws;i++) ecart=ecart+(float)((float)loss[i]/plays[i]-m)*((float)loss[i]/plays[i]-m);
	ecart=sqrt(ecart/(float)(Draws));

	fprintf(fic,"(%d,%f)+=(0,%f)-=(0,%f)\n", N,m,1.96*ecart/(sqrt(Draws)),1.96*ecart/(sqrt(Draws)));

	fclose(fic);
/*****************************/

    char str[10];
	sprintf(str, "%d_", N);

    fic=fopen(nom_fic9,"a");
    fic2=fopen(nom_fic26,"a");
	ecart=0.0;
	m=0.0;
	float mMin=0.0;
	float mMax=0.0;
	for (i=0;i<Draws;i++) {
		m=m+muMin[i]/muMax[i];
		mMin=muMin[i]+mMin;
		mMax=mMax+muMax[i];
	}
	m=m/(float)Draws;
	mMin=mMin/(float)Draws;
	mMax=mMax/(float)Draws;

	for(i=0;i<Draws;i++) ecart=ecart+(float)(muMin[i]/muMax[i]-m)*(muMin[i]/muMax[i]-m);
	ecart=sqrt(ecart/(float)(Draws));
    fprintf(fic,"(%d,%f)+=(0,%f)-=(0,%f)\n", N,m,1.96*ecart/(sqrt(Draws)),1.96*ecart/(sqrt(Draws)));
    fprintf(fic2,"(%d,%f)\n", N,(float)mMin/mMax);
    fprintf(fic2,"(min,%f)\n(max,%f)\n",(float)mMin,(float)mMax);

	fclose(fic);
	fclose(fic2);
	/*****************************************************/
	/*****************************************************/
	// mu_pi over time
	char str1[10];

	ecart=0.0;

	float* mm1;
	mm1=(float*)malloc(sizeof(float)*(T/(T/50)+1));
	for(i=0;i<T/(T/50)+1;i++)
        mm1[i]=0.0;

    for(int j=0;j<T/(T/50)+1;j++)
	    for (i=0;i<Draws;i++)
            mm1[j]=mm1[j]+average_mu[i][j];

	for(i=0;i<T/(T/50)+1;i++)
        mm1[i]=mm1[i]/(float)Draws;

    for(int j=0;j<T/(T/50)+1;j ++)
        {for(i=0;i<Draws;i++)

            ecart=ecart+(float)(average_mu[i][j]-mm1[j])*(average_mu[i][j]-mm1[j]);
        ecart=sqrt(ecart/(float)(Draws));

        ecart=0.0;
        }
/*******************************/

    char str2[10];
    char str3[10];
    sprintf(str1, "_%d_", N);
    sprintf(str2, "_%d_.txt", Algorithm);
    //sprintf(str3, "_%d.txt", exploit);
    strcat(str1,str2);
	//strcat(str1,str3);

	//strcpy(nom_fic19,nom_fichier);
	strcat(nom_fic19,"progress_PDR_");
	strcat(nom_fic19,str1);
    fic=fopen(nom_fic19,"w");

	//strcpy(nom_fic20,nom_fichier);
	strcat(nom_fic20,"progress_TIME_");
	strcat(nom_fic20,str1);
	FILE *fic3;
    fic3=fopen(nom_fic20,"w");

	//sprintf(str1, "matlab_%d_", N);
	//strcpy(nom_fic21,nom_fichier);
	strcat(nom_fic21,"progress_ERROR_");
	strcat(nom_fic21,str1);
    FILE *fic4;
	fic4=fopen(nom_fic21,"w");

	ecart=0.0;

	fic2=fopen(nom_fic10,"a");

	float* mm4;
	mm4=(float*)malloc(sizeof(float)*(T/(T/50)+1));
	for(i=0;i<T/(T/50)+1;i++)
        mm4[i]=0.0;

    for(int j=0;j<T/(T/50)+1;j++)
	    for (i=0;i<Draws;i++)
            mm4[j]=mm4[j]+average_mu[i][j];

	for(i=0;i<T/(T/50)+1;i++)
        mm4[i]=mm4[i]/(float)Draws;

    for(int j=0;j<T/(T/50)+1;j ++)
        {for(i=0;i<Draws;i++)

            ecart=ecart+(float)(average_mu[i][j]-mm4[j])*(average_mu[i][j]-mm4[j]);
        ecart=sqrt(ecart/(float)(Draws));
        float dur=0.0;
        for (i=0;i<Draws;i++) {
		dur=dur+duration[i];
        }
        dur=dur/Draws;
        fprintf(fic,"%f ", mm4[j]);
        fprintf(fic3,"%f ", dur+(float)j*(T/50));
        fprintf(fic4,"%f ", 1.96*ecart/(sqrt(Draws)));


        if(j==T/(T/50))fprintf(fic2,"(%d,%f)+=(0,%f)-=(0,%f)\n", N,mm1[j],1.96*ecart/(sqrt(Draws)),1.96*ecart/(sqrt(Draws)));
        ecart=0.0;
        }

	fclose(fic);
	fclose(fic3);
	fclose(fic4);
/**********************************************************************/

fic2=fopen(nom_fic11,"a");
	float* mm2;
	mm2=(float*)malloc(sizeof(float)*(T/(T/50)+1));
	for(i=0;i<T/(T/50)+1;i++)
        mm2[i]=0.0;

    for(int j=0;j<T/(T/50)+1;j++)
	    for (i=0;i<Draws;i++)
            mm2[j]=mm2[j]+collRate[i][j];

	for(i=0;i<T/(T/50)+1;i++)
        mm2[i]=mm2[i]/(float)Draws;

    for(int j=0;j<T/(T/50)+1;j ++)
        {for(i=0;i<Draws;i++)
            ecart=ecart+(float)(collRate[i][j]-mm2[j])*(collRate[i][j]-mm2[j]);
        ecart=sqrt(ecart/(float)(Draws));


        if(j==T/(T/50))fprintf(fic2,"(%d,%f)+=(0,%f)-=(0,%f)\n", N,mm2[j],1.96*ecart/(sqrt(Draws)),1.96*ecart/(sqrt(Draws)));
        ecart=0.0;
        }

    free(mm2);
	fclose(fic2);

/******************************************************************************/

	// Sample Complexity
	strcpy(nom_fic2,nom_fichier);
	strcat(nom_fic2,"_sampleComlexity.txt");
	fic=fopen(nom_fic2,"a");
	ecart=0.0;

	m=0.0;
	for (i=0;i<Draws;i++) {
		m=m+SampleC[i];
	}
	m=m/(float)Draws;
	for(i=0;i<Draws;i++) ecart=ecart+(float)(SampleC[i]-m)*(SampleC[i]-m);
	ecart=sqrt(ecart/(float)(Draws));
	fprintf(fic,"%f %f %f\n",m,m-1.96*ecart/(sqrt(Draws)),m+1.96*ecart/(sqrt(Draws)));



	fclose(fic);
/****************************************************************************/
	// communication cot
	strcpy(nom_fic2,nom_fichier);
	strcat(nom_fic2,"_commCost.txt");
	fic=fopen(nom_fic2,"a");
	ecart=0.0;
	m=0.0;

	if(comm==1){
        m=0.0;
        for (i=0;i<Draws;i++) {
            m=m+P[i];
        }

        m=m/(float)Draws;


        for(i=0;i<Draws;i++) ecart=ecart+(float)(P[i]-m)*(P[i]-m);
        ecart=sqrt(ecart/(float)(Draws));
        fprintf(fic,"%f %f %f\n",m,m-1.96*ecart/(sqrt(Draws)),m+1.96*ecart/(sqrt(Draws)));
	}

	fclose(fic);

	/****************************************************************************/
	// communication cot
	strcpy(nom_fic2,nom_fichier);
	strcat(nom_fic2,"_explorationDuration.txt");
	fic=fopen(nom_fic2,"a");
	ecart=0.0;
	m=0.0;

	if(comm==1){
        m=0.0;
        for (i=0;i<Draws;i++) {
            m=m+duration[i];
        }

        m=m/(float)Draws;


        for(i=0;i<Draws;i++) ecart=ecart+(float)(duration[i]-m)*(duration[i]-m);
        ecart=sqrt(ecart/(float)(Draws));
        fprintf(fic,"%f %f %f\n",m,m-1.96*ecart/(sqrt(Draws)),m+1.96*ecart/(sqrt(Draws)));
	}

	fclose(fic);

}


/**
sorts an array in ascending order
*/

int * sort( float *max)
{
    int i,j;
    float a;
    for (i = 0; i < M; ++i)
        {
            for (j = i + 1; j < M; ++j)
            {
                if (max[i] > max[j])
                {
                    a =  max[i];
                    max[i] = max[j];
                    max[j] = a;
                }
            }
        }

    return max;
}


/**
checks if the arm is one of the M best arms
returns its index in the top arms if yes, and
-1 otherwise
*/
int isOftheBest(int n, float* max, int index, int size)
{
    int i;
    for ( i=0; i < size; i++)
    {
        if (Player[n].B[index].mu >= max[i])
            return i;
    }

    return -1;
}

/** finds the collision rate
*/
float getCollisionRate(int n)
{
    return 1-pow(1-Player[n].p/Card(Player[n].A),N-1)*(1+(N-1)*Player[n].p/Card(Player[n].A));

}

/** tests if all players found the M best arms or not
*/
int allPlayersFinish()
{   int i;

    for (i=0;i<N;i++)
        if( Card(Player[i].A) > M)
            return 0;

    return 1;
}

/***************************************/
void findM_best()

{

    M_best=(int*)malloc(sizeof(int)*M);

    int k=0;
    for(int j=0;j<K;j++)
        if(Action[j]==1)
            {M_best[k]=j;
            printf("j=%d,M_best[%d]=%d\n",j,k,M_best[k]);
            k++;}

}

int playM_bestUniformly()
{
    int n = rand() % M ;
    return M_best[n];
}
