#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include <string.h>
#include "type.h"

/**Exploitaion phase
*/
void StartExploit()
{
    int t=0;
    int i=0;
    int k;
    int samples=0;
    float globalReward=0;
    float globalMean,y;
    int minProb=0;
    int maxProb=0;
    for(int n=0;n<N;n++)
        {
        if(Player[n].pr < Player[minProb].pr) minProb=n;
        if(Player[n].pr > Player[maxProb].pr) maxProb=n;

        }

    Pmin[dr]=Player[minProb].pr;
    Pmax[dr]=Player[maxProb].pr;

    printf("here i am %d\n",exploit);
    ///reward greedy policy DORG
    if(exploit==1)
    {
        printf("before reward greedy\n");
        dorg();
        while(t<T)
        {   globalT[dr]=globalT[dr]+1;
        if(globalT[dr]%(T/TimeDisplay)==0)fprintf(globalFic,"(%d,%f)\n", globalT[dr],(float)globalR[dr]/globalS[dr]);
            if(t==0)printf("mu_pi[%d][0]=%f\n",dr,mu_pi[dr][0]);
            if(t%(T/TimeDisplay)==0&&t!=0)
                {mu_pi[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(t+duration[dr]);
                average_mu[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(plays[dr]);
                collRate[dr][t/(T/TimeDisplay)]=(float)collisions[dr]/plays[dr];
                printf("%d:::plays[%d]=%d;Rewards[%d]=%f/t[%d]=%d=%f, colAvg=%f,avg=%f,loss[%d]=%f, X[%d]=%f\n\n",t/(T/TimeDisplay),dr,plays[dr],dr,Rewards[dr],dr,t,mu_pi[dr][t/(T/TimeDisplay)],collRate[dr][t/(T/TimeDisplay)],average_mu[dr][t/(T/TimeDisplay)],dr,(float)loss[dr],dr,(float)X[dr]/plays[dr]);
                }

            t++;
            float x=RAND_R(1.0);
            for (int n=0; n<N; n++)
            {
                if(isPlaying(n,x)==1){
                    samples++;
                    globalS[dr]=globalS[dr]+1;
                    if(Player[n].p==Player[n].pr) Player[n].k=Player[n].armToPlay;
                    else Player[n].k=uniformPlay();
                    k=Player[n].k;
                    Player[n].B[k].tk=Player[n].B[k].tk+1;
                    plays[dr]=plays[dr]+1;
                }

                else {
                    Player[n].k=-1;
                }
            }

            for (int n=0; n<N; n++)
            {
                k=Player[n].k;
                //reward gained by player n
                if(Player[n].k!=-1) {
                    y=GetReward(k,n,dr);
                    if(y==0.0){totalCollisions[dr]=totalCollisions[dr]+1;}
                    if(y==1.0) {Player[n].p=Player[n].pr;}
                    avg_arm[dr][k]=avg_arm[dr][k]+(float)y;
                    Rewards[dr]=Rewards[dr]+y;
                    globalR[dr]=globalR[dr]+y;
                    playersRewards[n]=playersRewards[n]+y;
                    globalReward=globalReward+y;
                    Player[n].B[k].mu=(float)y/(float)Player[n].B[k].tk+(float)(Player[n].B[k].tk-1)/(float)Player[n].B[k].tk*Player[n].B[k].mu;
                    Player[n].t=Player[n].t+1;
                }
            }
        }
        if(t%(T/TimeDisplay)==0) mu_pi[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(t+duration[dr]);
        if(t%(T/TimeDisplay)==0) average_mu[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(plays[dr]);
        if(t%(T/TimeDisplay)==0) collRate[dr][t/(T/TimeDisplay)]=(float)collisions[dr]/plays[dr];
        if(t%(T/TimeDisplay)==0) printf("%d:::plays[%d]=%d;Rewards[%d]=%f/t[%d]=%d=%f,collisions[%d]=%d, colAvg=%f,avg=%f loss[%d]=%f\n\n",t/(T/TimeDisplay),dr,plays[dr],dr,Rewards[dr],dr,t,mu_pi[dr][t/(T/50)],dr,collisions[dr],collRate[dr][t/(T/50)],average_mu[dr][t/(T/50)],dr,(float)loss[dr]);
        printf("mu(pi)=%f/%f----avg=%f\n\n",mu_pi[dr][TimeDisplay],expReward(),mu_pi[dr][TimeDisplay]/ expReward());
        printf("pdr(pi)=%f/%f---avg=%f\n\n",average_mu[dr][TimeDisplay],expPDR(),average_mu[dr][TimeDisplay]/expPDR());

    }


    ///fair greedy policy DOFG
    if(exploit==2)
    {
        playDiff=0.0;
        dofg();
        while(t<T)
        {   globalT[dr]=globalT[dr]+1;
        if(t%(T/TimeDisplay)==0&&t!=0)
        {fprintf(globalFic,"(%d,%f)\n", globalT[dr],(float)globalR[dr]/globalS[dr]);
        int minP=0;
        int maxP=0;
        for(int nn=0;nn<N;nn++)
            {playersMeans[dr][nn]=playersRewards[nn]/Player[nn].t;
            if(playersMeans[dr][nn]<playersMeans[dr][minP]) minP=nn;
            if(playersMeans[dr][nn]>playersMeans[dr][maxP]) maxP=nn;}
        fairness[dr][t/(T/TimeDisplay)]=playersMeans[dr][minP]/playersMeans[dr][maxP];
        printf("fairness=%f\n",fairness[dr][t/(T/TimeDisplay)]);
            }

            if(t==0)printf("mu_pi[%d][0]=%f\n",dr,mu_pi[dr][0]);
            if(t%(T/TimeDisplay)==0&&t!=0)
                {mu_pi[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(t+duration[dr]);
                fprintf(diffFile,"(%d,%f)\n", globalT[dr],plays[dr]-playDiff);
                playDiff=plays[dr];
                average_mu[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(plays[dr]);
                collRate[dr][t/(T/TimeDisplay)]=(float)collisions[dr]/plays[dr];
                printf("plays[%d]=%d;Rewards[%d]=%f/t[%d]=%d=%f, colAvg=%f\n",dr,plays[dr],dr,Rewards[dr],dr,t,mu_pi[dr][t/(T/TimeDisplay)],collRate[dr][t/(T/TimeDisplay)]);}

            t++;

            for (int n=0; n<N; n++)
            {float x=RAND_R(1.0);
                if(isPlaying(n,x)){
                    globalS[dr]=globalS[dr]+1;
                    samples++;

                    if(Player[n].p==Player[n].pr) Player[n].k=Player[n].armToPlay;
                    else Player[n].k=uniformPlay();
                    k=Player[n].k;
                    Player[n].B[k].tk=Player[n].B[k].tk+1;
                    plays[dr]=plays[dr]+1;
                    playsPerPL[dr][n]=playsPerPL[dr][n]+1;

                }

                else {
                    Player[n].k=-1;
                }
            }

            for (int n=0; n<N; n++)
            {
                k=Player[n].k;
                //reward gained by player n
                if(Player[n].k!=-1) {
                    y=GetReward(k,n,dr);
                    if(y==0.0){totalCollisions[dr]=totalCollisions[dr]+1;

                    }
                    if(y==1.0) {Player[n].p=Player[n].pr;

                                }
                    globalR[dr]=globalR[dr]+y;
                    Rewards[dr]=Rewards[dr]+y;

                    avg_arm[dr][k]=avg_arm[dr][k]+(float)y;
                    playersRewards[n]=playersRewards[n]+y;
                    globalReward=globalReward+y;
                    Player[n].B[k].mu=(float)y/(float)Player[n].B[k].tk+(float)(Player[n].B[k].tk-1)/(float)Player[n].B[k].tk*Player[n].B[k].mu;
                    Player[n].t=Player[n].t+1;
                }
            }
        }
        if(t%(T/TimeDisplay)==0) mu_pi[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(t+duration[dr]);
        if(t%(T/TimeDisplay)==0) average_mu[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(plays[dr]);
        if(t%(T/TimeDisplay)==0) collRate[dr][t/(T/TimeDisplay)]=(float)collisions[dr]/plays[dr];
        if(t%(T/TimeDisplay)==0&&t!=0)
        {
        int minP=0;
        int maxP=0;

        for(int nn=0;nn<N;nn++)
            {playersMeans[dr][nn]=playersRewards[nn]/Player[nn].t;
            if(playersMeans[dr][nn]<playersMeans[dr][minP]) minP=nn;
            if(playersMeans[dr][nn]>playersMeans[dr][maxP]) maxP=nn;}

        fairness[dr][t/(T/TimeDisplay)]=playersMeans[dr][minP]/playersMeans[dr][maxP];
        printf("fairness=%f\n",fairness[dr][t/(T/TimeDisplay)]);
            }
        printf("mu(pi)=%f/%f----avg=%f\n\n",mu_pi[dr][TimeDisplay],expReward(),mu_pi[dr][TimeDisplay]/ expReward());
        printf("pdr(pi)=%f/%f---avg=%f\n\n",average_mu[dr][TimeDisplay],expPDR(),average_mu[dr][TimeDisplay]/expPDR());

    }

    ///uniform
    if(exploit==3)
    {
        printf("uniform\n");

        while(t<T)
        {
            globalT[dr]=globalT[dr]+1;
            if(globalT[dr]%(T/TimeDisplay)==0)fprintf(globalFic,"(%d,%f)\n", globalT[dr],(float)globalR[dr]/globalS[dr]);
            if(t%(T/TimeDisplay)==0&&t!=0)
                {mu_pi[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(t);
                average_mu[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(plays[dr]);
                collRate[dr][t/(T/TimeDisplay)]=(float)collisions[dr]/plays[dr];
                printf("plays[%d]=%d;Rewards[%d]=%f/t[%d]=%d=%f,collisions[%d]=%d, colAvg=%f,avg=%f loss[%d]=%f, X[%d]=%f\n\n",dr,plays[dr],dr,Rewards[dr],dr,t,mu_pi[dr][t/(T/TimeDisplay)],dr,collisions[dr],collRate[dr][t/(T/TimeDisplay)],average_mu[dr][t/(T/TimeDisplay)],dr,(float)loss[dr],dr,(float)X[dr]/plays[dr]);}

            t++;
            float x=RAND_R(1.0);
            for (int n=0; n<N; n++)
            {
                if(isPlaying(n,x)){
                    samples++;
                    Player[n].k = selectChannel();
                    globalS[dr]=globalS[dr]+1;
                    k=Player[n].k;
                    Player[n].B[k].tk=Player[n].B[k].tk+1;
                    plays[dr]=plays[dr]+1;
                }

                else {
                    Player[n].k=-1;
                }
            }

            for (int n=0; n<N; n++)
            {
                k=Player[n].k;
                //reward gained by player n
                if(Player[n].k!=-1) {
                    y=GetReward(k,n,dr);
                    if(y==0.0)totalCollisions[dr]=totalCollisions[dr]+1;
                    globalR[dr]=globalR[dr]+y;
                    Rewards[dr]=Rewards[dr]+y;
                    avg_arm[dr][k]=avg_arm[dr][k]+(float)y;
                    playersRewards[n]=playersRewards[n]+y;
                    globalReward=globalReward+y;
                    Player[n].B[k].mu=(float)y/(float)Player[n].B[k].tk+(float)(Player[n].B[k].tk-1)/(float)Player[n].B[k].tk*Player[n].B[k].mu;
                    Player[n].t=Player[n].t+1;
                }
            }
        }
       if(t%(T/TimeDisplay)==0) mu_pi[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(t);
        if(t%(T/TimeDisplay)==0) average_mu[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(plays[dr]);
        if(t%(T/TimeDisplay)==0) collRate[dr][t/(T/TimeDisplay)]=(float)collisions[dr]/plays[dr];
        if(t%(T/TimeDisplay)==0) printf("plays[%d]=%d;Rewards[%d]=%f/t[%d]=%d=%f,collisions[%d]=%d, colAvg=%f,avg=%f loss[%d]=%f\n\n",dr,plays[dr],dr,Rewards[dr],dr,t,mu_pi[dr][t/(T/TimeDisplay)],dr,collisions[dr],collRate[dr][t/(T/TimeDisplay)],average_mu[dr][t/(T/TimeDisplay)],dr,(float)loss[dr]);


        D[dr]=(float)plays[dr]/globalT[dr];
        for(int j=0;j<K;j++)
        {D_k[dr][j]=(float)plPerArm[j];
            printf("\n\nDk=%f, D=%f, D1=%f, D2=%f, e-x[D[%d]]=%f\n\n", plPerArm[j],(float) plays[dr]/globalT[dr],((float)plays[dr]/globalT[dr]+log(2.0))/2.0,((float)plays[dr]/globalT[dr]-log(2.0))/2.0, j, exp(-1*plPerArm[j])  );
        }
    }

    ///UCB1
    if(exploit==4)
    {
        printf("UCB1\n");

        while(t<T)

        {
            globalT[dr]=globalT[dr]+1;
            if(globalT[dr]%(T/TimeDisplay)==0)fprintf(globalFic,"(%d,%f)\n", globalT[dr],(float)globalR[dr]/globalS[dr]);
            if(t%(T/TimeDisplay)==0&&t!=0)
                {mu_pi[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(t);
                average_mu[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(plays[dr]);
                collRate[dr][t/(T/TimeDisplay)]=(float)collisions[dr]/plays[dr];
                printf("plays[%d]=%d;Rewards[%d]=%f/t[%d]=%d=%f,collisions[%d]=%d, colAvg=%f,avg=%f loss[%d]=%f\n\n",dr,plays[dr],dr,Rewards[dr],dr,t,mu_pi[dr][t/(T/TimeDisplay)],dr,collisions[dr],collRate[dr][t/(T/TimeDisplay)],average_mu[dr][t/(T/TimeDisplay)],dr,(float)loss[dr]);
                }

            t++;
            float x=RAND_R(1.0);
            for (int n=0; n<N; n++)
            {
                if(isPlaying(n,x)){
                    samples++;
                    if(finish(n)==0)Player[n].k = selectChannel();
                    else
                    {
                    if(Player[n].p==Player[n].pr) Player[n].k=playArm_UCB (n);
                    else Player[n].k=uniformPlay();}
                    k=Player[n].k;
                    globalS[dr]=globalS[dr]+1;
                    if(t>=0.9*T)
                        {armsPlays[k]=armsPlays[k]+1;
                            plPerArm[k]=(float)armsPlays[k]/(globalT[dr]-0.9*T);
                        }

                    Player[n].B[k].tk=Player[n].B[k].tk+1;
                    plays[dr]=plays[dr]+1;
                }

                else {
                    Player[n].k=-1;
                }
            }

            for (int n=0; n<N; n++)
            {
                k=Player[n].k;
                //reward gained by player n
                if(Player[n].k!=-1) {
                    y=GetReward(k,n,dr);
                    if(y==0.0){totalCollisions[dr]=totalCollisions[dr]+1;}

                    if(y==1.0) Player[n].p=Player[n].pr;
                    Rewards[dr]=Rewards[dr]+y;
                    globalR[dr]=globalR[dr]+y;
                    avg_arm[dr][k]=avg_arm[dr][k]+(float)y;
                    playersRewards[n]=playersRewards[n]+y;
                    globalReward=globalReward+y;
                    Player[n].B[k].mu=(float)y/(float)Player[n].B[k].tk+(float)(Player[n].B[k].tk-1)/(float)Player[n].B[k].tk*Player[n].B[k].mu;
                    Player[n].t=Player[n].t+1;
                    updateUCB1 (n,t);
                }
            }
        }
        if(t%(T/TimeDisplay)==0) mu_pi[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(t);
        if(t%(T/TimeDisplay)==0) average_mu[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(plays[dr]);
        if(t%(T/TimeDisplay)==0) collRate[dr][t/(T/TimeDisplay)]=(float)collisions[dr]/plays[dr];
        if(t%(T/TimeDisplay)==0) printf("plays[%d]=%d;Rewards[%d]=%f/t[%d]=%d=%f,collisions[%d]=%d, colAvg=%f,avg=%f loss[%d]=%f\n\n",dr,plays[dr],dr,Rewards[dr],dr,t,mu_pi[dr][t/(T/TimeDisplay)],dr,collisions[dr],collRate[dr][t/(T/TimeDisplay)],average_mu[dr][t/(T/TimeDisplay)],dr,(float)loss[dr]);


        D[dr]=(float)plays[dr]/globalT[dr];
        for(int j=0;j<K;j++)
        {D_k[dr][j]=(float)plPerArm[j];
            printf("\n\nDk=%f, D=%f, D1=%f, D2=%f, e-x[D[%d]]=%f\n\n", plPerArm[j],(float) plays[dr]/globalT[dr],((float)plays[dr]/globalT[dr]+log(2.0))/2.0,((float)plays[dr]/globalT[dr]-log(2.0))/2.0, j, exp(-1*plPerArm[j])  );
        }

    }

     ///exp3
    if(exploit==5)
    {
        gamma=0.05;

        while(t<T)

        {
            globalT[dr]=globalT[dr]+1;
            if(globalT[dr]%(T/TimeDisplay)==0)fprintf(globalFic,"(%d,%f)\n", globalT[dr],(float)globalR[dr]/globalS[dr]);
            if(t%(T/TimeDisplay)==0&&t!=0)
                {mu_pi[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(t);
                average_mu[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(plays[dr]);
                collRate[dr][t/(T/TimeDisplay)]=(float)collisions[dr]/plays[dr];
                printf("plays[%d]=%d;Rewards[%d]=%f/t[%d]=%d=%f,collisions[%d]=%d, colAvg=%f,avg=%f loss[%d]=%f\n\n",dr,plays[dr],dr,Rewards[dr],dr,t,mu_pi[dr][t/(T/TimeDisplay)],dr,collisions[dr],collRate[dr][t/(T/TimeDisplay)],average_mu[dr][t/(T/TimeDisplay)],dr,(float)loss[dr]);
                }

            t++;
            float x=RAND_R(1.0);
            for (int n=0; n<N; n++)
            {
                if(isPlaying(n,x)){
                    p_exp3(n);
                    samples++;
                    Player[n].k=drawArm_exp3(n);
                    k=Player[n].k;
                    globalS[dr]=globalS[dr]+1;
                    if(t>=0.9*T)
                        {armsPlays[k]=armsPlays[k]+1;
                            plPerArm[k]=(float)armsPlays[k]/(globalT[dr]-0.9*T);
                        }

                    Player[n].B[k].tk=Player[n].B[k].tk+1;
                    plays[dr]=plays[dr]+1;

                }

                else {
                    Player[n].k=-1;
                }
            }

            for (int n=0; n<N; n++)
            {
                k=Player[n].k;
                //reward gained by player n
                if(Player[n].k!=-1) {
                    y=GetReward(k,n,dr);
                    if(y==0.0){totalCollisions[dr]=totalCollisions[dr]+1;}

                    if(y==1.0) Player[n].p=Player[n].pr;
                    Rewards[dr]=Rewards[dr]+y;
                    globalR[dr]=globalR[dr]+y;
                    avg_arm[dr][k]=avg_arm[dr][k]+(float)y;
                    playersRewards[n]=playersRewards[n]+y;
                    globalReward=globalReward+y;
                    Player[n].B[k].mu=(float)y/(float)Player[n].B[k].tk+(float)(Player[n].B[k].tk-1)/(float)Player[n].B[k].tk*Player[n].B[k].mu;
                    Player[n].t=Player[n].t+1;
                    update_wEXP(n ,y);
                }
            }
        }
        if(t%(T/TimeDisplay)==0) mu_pi[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(t);
        if(t%(T/TimeDisplay)==0) average_mu[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(plays[dr]);
        if(t%(T/TimeDisplay)==0) collRate[dr][t/(T/TimeDisplay)]=(float)collisions[dr]/plays[dr];
        if(t%(T/TimeDisplay)==0) printf("plays[%d]=%d;Rewards[%d]=%f/t[%d]=%d=%f,collisions[%d]=%d, colAvg=%f,avg=%f loss[%d]=%f\n\n",dr,plays[dr],dr,Rewards[dr],dr,t,mu_pi[dr][t/(T/TimeDisplay)],dr,collisions[dr],collRate[dr][t/(T/TimeDisplay)],average_mu[dr][t/(T/TimeDisplay)],dr,(float)loss[dr]);


        D[dr]=(float)plays[dr]/globalT[dr];

    }


    float expectedSamples=0.0;
    for(int n=0;n<N;n++)
        expectedSamples=Player[n].pr*T+expectedSamples;
    printf("expected samples=%f, real samples=%d\n\n",expectedSamples,plays[dr]);
    printf("new print\n\n");

    int minP=0;
    int maxP=0;

    for(int n=0;n<N;n++)
        {playersMeans[dr][n]=playersRewards[n]/Player[n].t;
         if(exploit==1 || exploit==2)
            {float prd=1.0;
             for(int n1=0;n1<N;n1++)
                if(n1!=n && Player[n].armToPlay==Player[n1].armToPlay) prd=prd*(1-Player[n1].pr);
            }

        if(playersMeans[dr][n]<playersMeans[dr][minP]) minP=n;
        if(playersMeans[dr][n]>playersMeans[dr][maxP]) maxP=n;

        }

    globalMean=globalReward/(float)T;

    printf("samples=%d, globalreward=%f, globalMean=%f\n",samples,globalReward,globalMean);
    printf("colliding players:%d/%d, percentage=%f\n",collisions[dr],samples,(float)collisions[dr]/(float)samples);
    muMax[dr]=playersMeans[dr][maxP];
    muMin[dr]=playersMeans[dr][minP];

    printf("minMean%d=%f/maxMean%d=%f=%f/%f__(%f)\n",minP,playersMeans[dr][minP],maxP,playersMeans[dr][maxP],playersMeans[dr][minP]/playersMeans[dr][maxP],expectedFair(minP,maxP),(1-Pmax[dr]) );
    printf("Player_0_mean=%f, Player_1297_mean=%f, fair=%f \n",playersMeans[dr][0],playersMeans[dr][N-1],playersMeans[dr][0]/playersMeans[dr][N-1]);
    printf("exploit end \n");

}
