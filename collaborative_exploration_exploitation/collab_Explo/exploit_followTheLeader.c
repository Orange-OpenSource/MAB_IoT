#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <math.h>
#include <float.h>
#include "type.h"

void scheduledForced(char *nom_fichier)
{

        float samplesPerArm= (float) log(2/delta)/(2*pow(epsilon2,2));
        Player[N-1].T_k=(int) ceil(log(2*K/delta)/(2*pow(epsilon2,2)));
        printf("total number of samples per arm=%d\n",Player[N-1].T_k );
        printf("total number of required samples=%f\n",samplesPerArm*K );
        printf("samples with selfish is %f\n",samplesPerArm*K*N);
        int minpl=slowPl();
        printf("slowest player %d\n",minpl);

        int k,n,play,yes=0;
        float y;
        float P_initial=Player[N-1].p;

        /**sending active rates*/
        int activeR=0;
        while(activeR<N)
        {
            //duration[dr]=duration[dr]+1;
            for(n=0;n<N;n++)
            {
                float x=RAND_R(1.0);
                play=isPlaying(n,x);
                if(play==1)
                    {   Player[n].k=PlayRoundRobin(n);
                        k=Player[n].k;
                        globalS[dr]=globalS[dr]+1;
                        plays[dr]=plays[dr]+1;//cou nt++;
                        Player[n].B[k].tk=Player[n].B[k].tk+1;
                        Player[n].t=Player[n].t+1;
                    }
                if(play==1 && activeRates[n]==Player[n].pr )
                {
                    y=0.0;
                    globalR[dr]=globalR[dr]+y;
                    avg_arm[dr][k]=avg_arm[dr][k]+(float)y;
                    Player[n].B[k].mu=(float)y/(float )Player[n].B[k].tk+(float)(Player[n].B[k].tk-1)/(float)Player[n].B[k].tk*Player[n].B[k].mu;
                    Rewards[dr]=Rewards[dr]+y;
                    playersRewards[n]=playersRewards[n]+y;
                    Player[n].k=-1;
                }
                if(play==0) Player[n].k=-1;
            }

            for(n=0;n<N;n++)
            {
                k=Player[n].k;

                if(Player[n].k!=-1) {
                    rateCost[dr]=rateCost[dr]+1;
                    y=GetReward(k,n,dr);
                    globalR[dr]=globalR[dr]+y;
                    avg_arm[dr][k]=avg_arm[dr][k]+(float)y;
                    Player[n].B[k].mu=(float)y/(float )Player[n].B[k].tk+(float)(Player[n].B[k].tk-1)/(float)Player[n].B[k].tk*Player[n].B[k].mu;
                    Rewards[dr]=Rewards[dr]+y;
                    playersRewards[n]=playersRewards[n]+y;
                    if (y==1.0 && activeRates[n]!=Player[n].pr)
                        {activeRates[n]=Player[n].pr;
                         activeR++;
                         }
                }
            }
        }
        printf("activeR=%d,rateCost[dr]=%d\n",activeR,rateCost[dr]);

        samples[dr]=0;
        /**exploration*/
        for(int i=0;i<K;i++)
        {
            Player[N-1].B[i].mu=0;
            Player[N-1].B[i].tk=0;
        }
        while(ForcedFinishEstimating()==0)
            {
             duration[dr]=duration[dr]+1;
             for (n=0;n<N-1;n++)
             {
                float x=RAND_R(1.0);
                play=isPlaying(n,x);
                if(play==1)
                    {   Player[n].k=PlayRoundRobin(n);
                        k=Player[n].k;
                        globalS[dr]=globalS[dr]+1;
                        plays[dr]=plays[dr]+1;//cou nt++;
                        Player[n].B[k].tk=Player[n].B[k].tk+1;
                        Player[n].t=Player[n].t+1;
                        y=0.0;
                        globalR[dr]=globalR[dr]+y;
                        avg_arm[dr][k]=avg_arm[dr][k]+(float)y;
                        Player[n].B[k].mu=(float)y/(float )Player[n].B[k].tk+(float)(Player[n].B[k].tk-1)/(float)Player[n].B[k].tk*Player[n].B[k].mu;
                        Rewards[dr]=Rewards[dr]+y;
                        playersRewards[n]=playersRewards[n]+y;
                    }

                Player[n].k=-1;
             }


                 float x=RAND_R(1.0);
                 n=N-1;

             //sending active rate or estimating
                play=isPlaying(n,x);
                if(play==1){Player[n].k=PlayRoundRobin(n);
                            k=Player[n].k;
                            plays[dr]=plays[dr]+1;
                            Player[n].B[k].tk=Player[n].B[k].tk+1;
                            Player[n].t=Player[n].t+1;
                            sampleComplexity[dr]=sampleComplexity[dr]+1;
                            samples[dr]=samples[dr]+1;
                        }

                if(play==0) Player[n].k=-1;


                k=Player[n].k;
                //reward gained by player n
                if(Player[n].k!=-1) {
                    y=GetReward(k,n,dr);
                    globalR[dr]=globalR[dr]+y;
                    avg_arm[dr][k]=avg_arm[dr][k]+(float)y;
                    Player[n].B[k].mu=(float)y/(float )Player[n].B[k].tk+(float)(Player[n].B[k].tk-1)/(float)Player[n].B[k].tk*Player[n].B[k].mu;
                    Player[n].B[k].mu=Player[n].B[k].mu;
                    Rewards[dr]=Rewards[dr]+y;
                    playersRewards[n]=playersRewards[n]+y;
                    }

            }

            for(int j=0;j<K;j++)
            {
                finalEstimation[j]=Player[N-1].B[j].mu;
                printf("estimation[%d]=%f(%f)\n",j,finalEstimation[j],Arm[j]);
            }
            printf("samples=%d duration=%d\n",samples[dr],duration[dr]);
            /**send estimations **/
            int mes=0;

            while (mes<1){
             //duration[dr]=duration[dr]+1;
             for (n=0;n<N-1;n++)
             {
                float x=RAND_R(1.0);
                play=isPlaying(n,x);
                if(play==1)
                    {   Player[n].k=PlayRoundRobin(n);
                        k=Player[n].k;
                        globalS[dr]=globalS[dr]+1;
                        plays[dr]=plays[dr]+1;//cou nt++;
                        Player[n].B[k].tk=Player[n].B[k].tk+1;
                        Player[n].t=Player[n].t+1;
                        y=0.0;
                        globalR[dr]=globalR[dr]+y;
                        avg_arm[dr][k]=avg_arm[dr][k]+(float)y;
                        Player[n].B[k].mu=(float)y/(float )Player[n].B[k].tk+(float)(Player[n].B[k].tk-1)/(float)Player[n].B[k].tk*Player[n].B[k].mu;
                        Rewards[dr]=Rewards[dr]+y;
                        playersRewards[n]=playersRewards[n]+y;
                    }

                Player[n].k=-1;
             }


                 float x=RAND_R(1.0);
                 n=N-1;

             //sending active rate or estimating
                play=isPlaying(n,x);
                if(play==1){Player[n].k=PlayRoundRobin(n);
                            k=Player[n].k;
                            plays[dr]=plays[dr]+1;
                            Player[n].B[k].tk=Player[n].B[k].tk+1;
                            Player[n].t=Player[n].t+1;
                            sampleComplexity[dr]=sampleComplexity[dr]+1;
                                //printf("%d   ", Player[minpl].B[aa].tk);printf("/%d  sc(%d)\n",Player[minpl].T_k,sampleComplexity[i]);}
                        }

                if(play==0) Player[n].k=-1;


                k=Player[n].k;
                //reward gained by player n
                if(Player[n].k!=-1) {
                    y=GetReward(k,n,dr);
                    estimationCost[dr]=estimationCost[dr]+1;
                    if(y==1.0) mes++;
                    globalR[dr]=globalR[dr]+y;
                    avg_arm[dr][k]=avg_arm[dr][k]+(float)y;
                    Player[n].B[k].mu=(float)y/(float )Player[n].B[k].tk+(float)(Player[n].B[k].tk-1)/(float)Player[n].B[k].tk*Player[n].B[k].mu;
                    Player[n].B[k].mu=Player[n].B[k].mu;
                    Rewards[dr]=Rewards[dr]+y;
                    playersRewards[n]=playersRewards[n]+y;
                    }
                }


            mu_pi[dr][0]=(float)Rewards[dr]/duration[dr];
            average_mu[dr][0]=(float)Rewards[dr]/plays[dr];
            collRate[dr][0]=(float)collisions[dr]/plays[dr];

            printf("rewards=%f, avg=%f,plays=%d\n",Rewards[dr], average_mu[dr][0],plays[dr]);
            printf("estimationCost=%d, comCost=%d\n",estimationCost[dr],estimationCost[dr]+rateCost[dr]);


            Player[N-1].p=P_initial;
}

