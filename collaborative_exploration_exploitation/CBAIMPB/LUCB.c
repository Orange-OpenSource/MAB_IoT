
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include <string.h>
#include "type.h"


int *P;

/**returns the confidence level on the mean reward of arm k by player n at time t
*/
float confInt(int t, int n, int k)
{
    float betaa=(float)1.96*Player[n].B[k].stdd/sqrt(Player[n].B[k].tk*(float)log(pow(t,2)/eta));
    return betaa;
}

/**returns the set of arms that have not been played in phase 1 yet
*/
int allArmsPlayed(int **armsPlayed,int n)
{
    for(int i=0;i<K;i++)
    {
        if (armsPlayed[n][i]==0)
            return 0;
    }
    return 1;

}
/**
sorts an array in ascending order
*/

float * sort2Arrays( float *max,int* maxArms,int M)
{
    int i,j,k;
    float a;
    for (i = 0; i < M; ++i)
        {
            for (j = i + 1; j < M; ++j)
            {
                if (max[i] > max[j])
                {
                    a =  max[i];
                    k = maxArms[i];

                    max[i] = max[j];
                    maxArms[i] = maxArms[j];

                    max[j] = a;
                    maxArms[j] = k;
                }
            }
        }

    return max;
}

/**finds the optimal M arms for player n
*/
int* findOptimals(int n)
{
    int i,j,k=0;
	float* max;
	int* optimal;

	max=(float*)malloc(sizeof(float)*(M));
	optimal=(int*)malloc(sizeof(int)*(M));

    //initialize array by zeros
    for (i = 0; i<M; i++)
        {max[i] = -1.0;
        optimal[i]=-1;
        }


    // find the best arms
	for (i=0;i<K;i++) {
		if (Player[n].A[i] == 1 && isOftheBest(n, max,i,M) !=-1 ) {
			max [isOftheBest(n, max,i,M)]= Player[n].B[i].mu;
			optimal[isOftheBest(n, max,i,M)]=i;
			max=sort2Arrays(max,optimal,M);
		}
	}

	return optimal;

}

/**finds the K-M suboptimal arms
*/
int* findNonOptimals(int n)
{
    int i,j,k=0,yes=0;
	int* nonOptimal;
	int* optimal;
	nonOptimal=(int*)malloc(sizeof(int)*(K-M));
    optimal=(int*)malloc(sizeof(int)*(M));


	optimal=findOptimals(n);

	for(i=0;i<K;i++)
        {for(j=0;j<M; j++)
            if( optimal[j]==i)
                yes=1;
        if(yes==0)
            {nonOptimal[k]=i;
            k++;}
            yes=0;
        }

   return nonOptimal;
}

/**find the arm of the highest upper confidence bound in the K-M suboptimal arms
*/

float findBestNonOptimal(int n)
{
    int* nonOptimals;
	nonOptimals=findNonOptimals(n);
	if(nonOptimals==NULL)printf("problem *****\n");

	float max=-INFINITY;
	int maxArm=-1;
	int i;

	for(i=0;i< K-M; i++)
    {
        if(Player[n].B[nonOptimals[i]].UCB > max)
        {
            max=Player[n].B[nonOptimals[i]].UCB;
            maxArm=nonOptimals[i];
        }
    }
	return max;
}

/**find the arm of the lowest lower confidence bound in the M optimal arms
*/

float findWorstOptimal(int n)
{
    int* Optimals;
	Optimals=findOptimals(n);

	float min=INFINITY;
	int minArm=-1;
	int i;

	for(i=0;i< M; i++)
    {
        if(Player[n].B[Optimals[i]].LCB < min)
        {
            min=Player[n].B[Optimals[i]].LCB;
            minArm=Optimals[i];
        }
    }
	return min;
}

/**tests whether the player stops searching and sends messages
*/

int stop(int n)
{
    float max=findBestNonOptimal(n);
    float min=findWorstOptimal(n);


    if(max-min < epsilon  &&(max!=min!=0))
    {

        int* nonOptimals;
        nonOptimals=findNonOptimals(n);

        if(!sameVector(nonOptimals,Player[n].nonOptimals,K-M))
        {
            for(int i=0; i<K-M; i++)
                Lambda[n][Player[n].nonOptimals[i]]=0;

            for(int i=0; i<K-M; i++)
                Lambda[n][nonOptimals[i]]=1;

            for(int j=0;j<K-M;j++)
                Player[n].nonOptimals[j]=nonOptimals[j];
            free(nonOptimals);
            return 1;
            }
    }

    return 0;
}

/**tests whether the player stops searching and sends messages
*/

int stop_reset(int n)
{
    float max=findBestNonOptimal(n);

    float min=findWorstOptimal(n);

    if(max-min < epsilon  &&(max!=min!=0))
    {
        int* nonOptimals;
        nonOptimals=findNonOptimals(n);

        for(int i=0; i<K-M; i++)
            {Lambda[n][nonOptimals[i]]++; }

        for(int j=0;j<K-M;j++)
            Player[n].nonOptimals[j]=nonOptimals[j];
            for (int i=0;i<K;i++) {
                Player[n].B[i].mu=0.0;
                Player[n].B[i].tk=0;
                Player[n].B[i].UCB=INFINITY;
                Player[n].B[i].LCB=-INFINITY;
                Player[n].B[i].var=0;
            }
        return 1;
    }
    return 0;
}

int RoundRobinn(int k, int **A, int n)
// Joue à tour de rôle les actions possibles
{
	int i=k+1;

	if (i >= K) i=0;

	while (i<K && A[n][i] == 1) {
		i++;
		if (i==K) i=0;
	}
	return i;
}

int chooseNotPlayedArm(int **A, int n)
{
	int i,k;
	float a;
	a=floor(RAND_R((float)K));
	k=(int)a;
	i=RoundRobinn(k,A,n);
	return i;

}


/** This is the decentralized LUCB algorithm
    */
int PlayNetwork31(char *nom_fichier)
{
    int i,j,n,k,t,display,s,sc;
	float R,y;

	//indicates if the player has finished playing each arms once in LUCB or not
	int *phase1;
	phase1=(int *)malloc(sizeof(int)*N);


    int **armsPlayed;
    armsPlayed=(int **)malloc(sizeof(int *)*N);
	for (i=0;i<N;i++) armsPlayed[i]=(int *)malloc(sizeof(int)*K);

     srand ( time(NULL) );
    // required number of players to eliminate an arm
	printf("M=%d\n",(int)ceil(log(delta)/log(eta)));
	P=(int *)malloc(sizeof(int)*Draws);

    for (i=0;i<Draws;i++) {

		InitServer();
		InitPlayers();
		initializeActiveRates();
		InitAction();
		k=0;t=1;display=0;R=0.0;s=0;sc=0;

		P[i]=0;

		for (n=0; n<N; n++)
            {
                phase1[n]=0;
                for(int i=0; i<K; i++)
                    armsPlayed[n][i]=0;
            }



		while (Card(Action) > M ) {
                duration[i]++;
            n=0;
            // player n is sampled
            for (n=0; n<N; n++)
            {
                if(isPlaying(n)){
                        sc++;
                        plays[i]=plays[i]+1;
                       // test if no arms are available to player n
                        if (Card(Player[n].A) == 0) printf("zut %d\n",n);

                        // player n plays the arms in phase 1
                        if(phase1[n]==0){//printf("yes*** \n");
                            if(allArmsPlayed(armsPlayed,n)==1) {phase1[n]=1;}

                            else
                                {Player[n].k=chooseNotPlayedArm(armsPlayed,n);

                                k=Player[n].k;
                                nb_plays[k]++;

                                armsPlayed[n][k]=1;
                                Player[n].B[k].tk=Player[n].B[k].tk+1;
                                }
                            }
                        // player n selects one arm randomly
                        if(phase1[n]==1){
                            Player[n].k=RandomChoice(Player[n].A);
                            k=Player[n].k;
                            nb_plays[k]++;
                            Player[n].B[k].tk=Player[n].B[k].tk+1;
                        }

                }

                else {
                    Player[n].k=-1;
                }

            }
            n=0;
                for (n=0; n<N; n++)
            {

                k=Player[n].k;

                //reward gained by player n
                if(Player[n].k!=-1) {
                    y=GetReward(k,n,i);
                    Rewards[i]=Rewards[i]+y;
                    playersRewards[n]=playersRewards[n]+y;
                    global_mu[k]=(float)y/(float )nb_plays[k]+(float)(nb_plays[k]-1)/(float)nb_plays[k]*global_mu[k];

                    Player[n].B[k].mu =(float)y/(float )Player[n].B[k].tk+(float)(Player[n].B[k].tk-1)/(float)Player[n].B[k].tk*Player[n].B[k].mu;
                    Player[n].B[k].stdd=sqrt(((float )Player[n].B[k].stdd*((float )Player[n].B[k].tk-1)+pow((float)y-Player[n].B[k].mu,2))/((float )Player[n].B[k].tk));
                    Player[n].t = Player[n].t+1;
                    Player[n].B[k].LCB = Player[n].B[k].mu -confInt(Player[n].t,n,k);
                    Player[n].B[k].UCB = Player[n].B[k].mu +confInt(Player[n].t,n,k);

                    if ((reset&&stop_reset(n)) || (!reset&&stop(n))) {
                        P[i]=P[i]+1;
                        CallServer();
                    }
                    R=R+Arm[0]-(float)y;

                    if (display == TimeDisplay) {
                        display=0;
                        Logs[i][s]=R;
                        s++;
                    }
                }

            }

			if ( Card(Action) ==M ) {

                P[i]=P[i]+N;
				SampleC[i]=sc;
				printf("SC[%d]=%d M=%d Votes=%d plays=%d collisions=%d********************\n",i,SampleC[i],P[i]+N,P[i],plays[i],collisions[i]);

				//the remaining action
				for (j=0;j<K;j++) if (Action[j]==1) printf ("k*=%d played=%d mu=%f\n",j,nb_plays[j], global_mu[j]); printf("\n");

			}

		}
		printf("plays=%d\n",plays[i]);
        average_mu[i][0]=(float)Rewards[i]/plays[i];
        collRate[i][0]=(float)collisions[i]/plays[i];
        int dr=i;
        printf("average_mu[i][0]=%f, rewards=%f, plays=%d,collRate[i][0]=%f\n",average_mu[i][0],(float)Rewards[i],plays[i],collRate[i][0]);




        /**exploitation*/

        findM_best();
        printf("playing best arms \n");
        int t=0;
        int nb=0;
        int totalnb=0;

        while(t<T)
        {
            if(t%(T/TimeDisplay)==0&&t!=0)
                {
                average_mu[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(plays[dr]);
                collRate[dr][t/(T/TimeDisplay)]=(float)collisions[dr]/plays[dr];
                printf("%d:::plays[%d]=%d;Rewards[%d]=%f/t[%d]=%d, colAvg=%f,avg=%f,loss[%d]=%f\n\n",t/(T/TimeDisplay),dr,plays[dr],dr,Rewards[dr],dr,t,collRate[dr][t/(T/TimeDisplay)],average_mu[dr][t/(T/TimeDisplay)],dr,(float)loss[dr]);
                }

            t++;
            float x=RAND_R(1.0);
            for (int n=0; n<N; n++)
            {
                if(isPlaying(n,x)){
                        nb++;
                        totalnb++;
                    Player[n].k=playM_bestUniformly();
                    k=Player[n].k;
                    Player[n].B[k].tk=Player[n].B[k].tk+1;
                    plays[dr]=plays[dr]+1;
                }

                else {
                    Player[n].k=-1;
                }
            }
            nb=0;
            for (int n=0; n<N; n++)
            {
                k=Player[n].k;
                //reward gained by player n
                if(Player[n].k!=-1) {
                    y=GetReward(k,n,dr);
                    Rewards[dr]=Rewards[dr]+y;
                    playersRewards[n]= playersRewards[n]+y;
                    Player[n].B[k].mu=(float)y/(float)Player[n].B[k].tk+(float)(Player[n].B[k].tk-1)/(float)Player[n].B[k].tk*Player[n].B[k].mu;
                    Player[n].t=Player[n].t+1;
                }
            }
        }
        if(t%(T/TimeDisplay)==0) average_mu[dr][t/(T/TimeDisplay)]=(float)Rewards[dr]/(plays[dr]);
        if(t%(T/TimeDisplay)==0) collRate[dr][t/(T/TimeDisplay)]=(float)collisions[dr]/plays[dr];
        if(t%(T/TimeDisplay)==0) printf("%d:::plays[%d]=%d;Rewards[%d]=%f/t[%d]=%d,collisions[%d]=%d, colAvg=%f,avg=%f loss[%d]=%f\n\n",t/(T/TimeDisplay),dr,plays[dr],dr,Rewards[dr],dr,t,dr,collisions[dr],collRate[dr][t/(T/50)],average_mu[dr][t/(T/50)],dr,(float)loss[dr]);

        int minP=0;
        int maxP=0;

        for(int n=0;n<N;n++)
            {playersMeans[i][n]=playersRewards[n]/Player[n].t;

            if(playersMeans[i][n]<playersMeans[i][minP]) minP=n;
            if(playersMeans[i][n]>playersMeans[i][maxP]) maxP=n;
            }
        muMax[i]=playersMeans[i][maxP];
        muMin[i]=playersMeans[i][minP];
        printf("mumax=%f\n",muMax[i]);
        }
	printf("number of remaining actions is %d \n",Card(Action));






	PlotCurve(nom_fichier);


	return 1;
}

