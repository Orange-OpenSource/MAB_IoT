
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include <string.h>
#include "type.h"

int *P;

/**returns a random number between 0 and x
*/
float RAND_R(float x)
{
    x=(float)rand()/(double)(RAND_MAX);
	return x;

}


/** returns the cardinal of AD
*/
int Card(int * AD)
{
	int i,s;

	s=0;
	for (i=0;i<K;i++) {
		if (AD[i]==1) s++;
	}
	return s;
}

/**plays the arms in round robin
*/
int RoundRobin(int k, int *A)
{
	int i=k+1;

	if (i >= K) i=0;

	while (i<K && A[i] == 0) {
		i++;
		if (i==K) i=0;
	}
	return i;
}

/** chooses uniformly an arm within the K arms*/
int uniformPlay()
{
    int r = rand()%K;
    return r;
}

/**counts the number of times an arm k is played by all players*/
int played(int k)
{
    int sum=0;
    for(int i=0;i<N;i++)
        sum=sum+Player[i].B[k].tk;
    return sum;
}

/**sorts players in decreasing order of their probas to play
*/
int* sortPlayers()
{
    float* sorted=(float*)malloc(sizeof(float)*N);
    int* sortedPlayers=(float*)malloc(sizeof(int)*N);
    for(int i=0;i<N;i++)
        {sorted[i]=Player[i].pr;
        sortedPlayers[i]=i;}

    int i,j,b;
    float a;
    for (i = 0; i < N; ++i)
        {
            for (j = i + 1; j < N; ++j)
            {
                if (sorted[i] < sorted[j])
                {
                    a =  sorted[i];
                    b = sortedPlayers[i];

                    sorted[i] = sorted[j];
                    sortedPlayers[i]=sortedPlayers[j];

                    sorted[j] = a;
                    sortedPlayers[j]=b;
                }
            }
        }
    return sortedPlayers;

}

/**sorts players in increasing order of their probas to play
*/
int* sortPlayersReverse()
{
    float* sorted=(float*)malloc(sizeof(float)*N);
    int* sortedPlayers=(float*)malloc(sizeof(int)*N);
    for(int i=0;i<N;i++)
        {sorted[i]=Player[i].pr;
        sortedPlayers[i]=i;}

    int i,j,b;
    float a;
    for (i = 0; i < N; ++i)
        {
            for (j = i + 1; j < N; ++j)
            {
                if (sorted[i] > sorted[j])
                {
                    a =  sorted[i];
                    b = sortedPlayers[i];

                    sorted[i] = sorted[j];
                    sortedPlayers[i]=sortedPlayers[j];

                    sorted[j] = a;
                    sortedPlayers[j]=b;
                }
            }
        }

    return sortedPlayers;

}

/**returns 1 if the two vectors are equal*/
int sameVector(int *A, int *B, int n)
{
    for(int i=0; i<n; i++)
        if(A[i]!=B[i]) return 0;
    return 1;
}

/**initializes the server*/
void InitServer()
{
	int i,j;


	for(i=0;i<K;i++)
        {global_mu[i]=0.0; nb_plays[i]=0;}

    strcpy(nom_globalFic,"GLOBALEXPECTEDREWARD.txt");
    globalFic=fopen(nom_globalFic,"w");

}


/**returns 1 if player n is playing aac to its active rate
*/
int isPlaying(int n, float x)
{
    float p=Player[n].p;
    randX=RAND_R(1.0);

    if(randX<=p)
        return 1;
    return 0;
}

/**initializes the text files
*/
void initFiles(char *nom_fichier)
{
    strcpy(nom_fic1,nom_fichier);
    strcat(nom_fic1,"_samplesUntilEstimate.txt");
    //fic=fopen(nom_fic1,"w");

    strcpy(nom_fic2,nom_fichier);
	strcat(nom_fic2,"_commCost.txt");
	//fic=fopen(nom_fic2,"w");

	strcpy(nom_fic3,nom_fichier);
	strcat(nom_fic3,"_sampleComplexity.txt");
	//fic=fopen(nom_fic3,"w");

	strcpy(nom_fic4,nom_fichier);
	strcat(nom_fic4,"_collisionRate.txt");
	//fic=fopen(nom_fic4,"w");

	strcpy(nom_fic5,nom_fichier);
	strcat(nom_fic5,"_SampleComplexity.txt");
	//fic=fopen(nom_fic5,"w");

	strcpy(nom_fic6,nom_fichier);
	strcat(nom_fic6,"_ExploreDuration.txt");
	//fic=fopen(nom_fic6,"w");

	strcpy(nom_fic8,nom_fichier);
	strcat(nom_fic8,"_meanRewards.txt");
	//fic2=fopen(nom_fic8,"w");

	strcpy(nom_fic9,nom_fichier);
	strcat(nom_fic9,"_fairnessLevel.txt");
	//fic=fopen(nom_fic9,"w");

	strcpy(nom_fic26,nom_fichier);
	strcat(nom_fic26,"_min_max2.txt");
	//fic=fopen(nom_fic26,"w");

	strcpy(nom_fic10,nom_fichier);
	strcat(nom_fic10,"_RewardMean.txt");
	//fic2=fopen(nom_fic10,"w");

	strcpy(nom_fic11,nom_fichier);
	strcat(nom_fic11,"_InternalCollision_rate.txt");
	//fic2=fopen(nom_fic11,"w");

	strcpy(nom_fic15,nom_fichier);
	strcat(nom_fic15,"_totalCollision_rate_N.txt");
	//fic=fopen(nom_fic15,"w");

	strcpy(nom_fic16,nom_fichier);
	strcat(nom_fic16,"_D_k.txt");
	//fic=fopen(nom_fic16,"w");

	strcpy(nom_fic17,nom_fichier);
	strcat(nom_fic17,"_pdrPerArm.txt");
	//fic=fopen(nom_fic17,"w");

	strcpy(nom_fic18,nom_fichier);
	strcat(nom_fic18,"_ExtrCollisionRate.txt");
	//fic=fopen(nom_fic18,"w");

	//strcpy(nom_fic22,nom_fichier);
	//strcat(nom_fic22,"_playsPerPlayer.txt");
	//fic=fopen(nom_fic22,"w");

	strcpy(nom_fic23,nom_fichier);
	strcat(nom_fic23,"PlayersMeans.txt");
	//fic=fopen(nom_fic23,"w");

	strcpy(nom_fic24,nom_fichier);
	strcat(nom_fic24,"EX_PlayersMeans.txt");
	//fic=fopen(nom_fic24,"w");

	strcpy(nom_fic25,nom_fichier);
	strcat(nom_fic25,"EX_PlaysPerPlayer.txt");
	//fic=fopen(nom_fic25,"w");

	strcpy(nom_fic27,nom_fichier);
	strcat(nom_fic27,"_FAIRNESS.txt");
	//fic=fopen(nom_fic27,"w");
}

/** extracts the results and writes them on the files
*/
void PlotCurve(char *nom_fichier)
{
	int i,j,s,S;
	float m,ecart,mD;
	char str[10];

/***************************/


	fic=fopen(nom_fic2,"a");
	ecart=0.0;
	m=0.0;
	for (i=0;i<Draws;i++) {
		m=m+rateCost[i]+estimationCost[i];
	}
	m=m/(float)Draws;
	for(i=0;i<Draws;i++) ecart=ecart+(float)(rateCost[i]+estimationCost[i]-m)*(rateCost[i]+estimationCost[i]-m);
	ecart=sqrt(ecart/(float)(Draws));
    fprintf(fic,"(%d,%f)+=(0,%f)-=(0,%f)\n", N,m,1.96*ecart/(sqrt(Draws)),1.96*ecart/(sqrt(Draws)));

	fclose(fic);
/*****************************/

fic=fopen(nom_fic18,"a");
	ecart=0.0;
	m=0.0;
	for (i=0;i<Draws;i++) {
		m=m+(float)loss[i]/plays[i];
	}
	m=m/(float)Draws;
	for(i=0;i<Draws;i++) ecart=ecart+(float)((float)loss[i]/plays[i]-m)*((float)loss[i]/plays[i]-m);
	ecart=sqrt(ecart/(float)(Draws));

	fprintf(fic,"(%d,%f)+=(0,%f)-=(0,%f)\n", N,m,1.96*ecart/(sqrt(Draws)),1.96*ecart/(sqrt(Draws)));

	fclose(fic);
/*****************************/

	fic=fopen(nom_fic5,"a");

	ecart=0.0;
	m=0.0;
	for (i=0;i<Draws;i++) {
		m=m+(float)samples[i];
	}
	m=m/(float)Draws;
	for(i=0;i<Draws;i++) ecart=ecart+(float)((float)samples[i]-m)*((float)samples[i]-m);
	ecart=sqrt(ecart/(float)(Draws));
	fprintf(fic,"(%d,%f)+=(0,%f)-=(0,%f)\n", N,m,1.96*ecart/(sqrt(Draws)),1.96*ecart/(sqrt(Draws)));

	fclose(fic);
	/**************************/


	fic=fopen(nom_fic6,"a");
	ecart=0.0;
	m=0.0;
	for (i=0;i<Draws;i++) {
		m=m+duration[i];
	}
	m=m/(float)Draws;
	float dur=(float)m;
	for(i=0;i<Draws;i++) ecart=ecart+(float)(duration[i]-m)*(duration[i]-m);
	ecart=sqrt(ecart/(float)(Draws));
    fprintf(fic,"(%d,%f)+=(0,%f)-=(0,%f)\n", N,m,1.96*ecart/(sqrt(Draws)),1.96*ecart/(sqrt(Draws)));

	fclose(fic);
	/*****************************************************/

	// mu_pi over time
	char str1[10];

	ecart=0.0;
	fic2=fopen(nom_fic10,"a");

	float* mm1;
	mm1=(float*)malloc(sizeof(float)*(T/(T/50)+1));
	for(i=0;i<T/(T/50)+1;i++)
        mm1[i]=0.0;

    for(int j=0;j<T/(T/50)+1;j++)
	    for (i=0;i<Draws;i++)
            mm1[j]=mm1[j]+average_mu[i][j];

	for(i=0;i<T/(T/50)+1;i++)
        mm1[i]=mm1[i]/(float)Draws;

    for(int j=0;j<T/(T/50)+1;j ++)
        {for(i=0;i<Draws;i++)

            ecart=ecart+(float)(average_mu[i][j]-mm1[j])*(average_mu[i][j]-mm1[j]);
        ecart=sqrt(ecart/(float)(Draws));

        if(j==T/(T/50))fprintf(fic2,"(%d,%f)+=(0,%f)-=(0,%f)\n", N,mm1[j],1.96*ecart/(sqrt(Draws)),1.96*ecart/(sqrt(Draws)));
        ecart=0.0;
        }

	fclose(fic);
	fclose(fic2);
/*******************************/

	fic2=fopen(nom_fic11,"a");
	float* mm2;
	mm2=(float*)malloc(sizeof(float)*(T/(T/50)+1));
	for(i=0;i<T/(T/50)+1;i++)
        mm2[i]=0.0;

    for(int j=0;j<T/(T/50)+1;j++)
	    for (i=0;i<Draws;i++)
            mm2[j]=mm2[j]+collRate[i][j];

	for(i=0;i<T/(T/50)+1;i++)
        mm2[i]=mm2[i]/(float)Draws;

    for(int j=0;j<T/(T/50)+1;j ++)
        {for(i=0;i<Draws;i++)
            ecart=ecart+(float)(collRate[i][j]-mm2[j])*(collRate[i][j]-mm2[j]);
        ecart=sqrt(ecart/(float)(Draws));

        if(j==T/(T/50))fprintf(fic2,"(%d,%f)+=(0,%f)-=(0,%f)\n", N,mm2[j],1.96*ecart/(sqrt(Draws)),1.96*ecart/(sqrt(Draws)));
        ecart=0.0;
        }
	//fprintf(fic,"%f %f %f\n",m,m-1.96*ecart/(sqrt(Draws)),m+1.96*ecart/(sqrt(Draws)));

    free(mm2);
	fclose(fic2);
/*******************************/
    char str2[10];
    char str3[10];
    sprintf(str1, "_%d_", N);
    sprintf(str2, "_%d_", Algorithm);
    sprintf(str3, "_%d.txt", exploit);
    strcat(str1,str2);
	strcat(str1,str3);

	//strcpy(nom_fic19,nom_fichier);
	strcat(nom_fic19,"pdrProgress");
	strcat(nom_fic19,str1);
    fic=fopen(nom_fic19,"w");

	//strcpy(nom_fic20,nom_fichier);
	strcat(nom_fic20,"pdrProgress_TIME_");
	strcat(nom_fic20,str1);
	FILE *fic3;
    fic3=fopen(nom_fic20,"w");

	//sprintf(str1, "matlab_%d_", N);
	//strcpy(nom_fic21,nom_fichier);
	strcat(nom_fic21,"pdrProgress_ERROR_");
	strcat(nom_fic21,str1);
    FILE *fic4;
	fic4=fopen(nom_fic21,"w");

	ecart=0.0;
	//fprintf(fic,"contains the value of mu_pi in specific intervals of time over the number of plays\n");

	//strcpy(nom_fic10,nom_fichier);
	//strcat(nom_fic10,"_average_mu_N.txt");
	fic2=fopen(nom_fic10,"a");

	float* mm4;
	mm4=(float*)malloc(sizeof(float)*(T/(T/50)+1));
	for(i=0;i<T/(T/50)+1;i++)
        mm4[i]=0.0;

    for(int j=0;j<T/(T/50)+1;j++)
	    for (i=0;i<Draws;i++)
            mm4[j]=mm4[j]+average_mu[i][j];

	for(i=0;i<T/(T/50)+1;i++)
        mm4[i]=mm4[i]/(float)Draws;

    for(int j=0;j<T/(T/50)+1;j ++)
        {for(i=0;i<Draws;i++)

            ecart=ecart+(float)(average_mu[i][j]-mm4[j])*(average_mu[i][j]-mm4[j]);
        ecart=sqrt(ecart/(float)(Draws));
        if(exploit>=5){ fprintf(fic,"%f ", mm4[j]);
                        fprintf(fic3,"%f ", (float)j*(T/50));
                        fprintf(fic4,"%f ", 1.96*ecart/(sqrt(Draws)));
                        }
        else{fprintf(fic,"%f ", mm4[j]);
             fprintf(fic3,"%f ", dur+(float)j*(T/50));
             fprintf(fic4,"%f ", 1.96*ecart/(sqrt(Draws)));
            }

        //if(j==T/(T/50))fprintf(fic2,"(%d,%f)+=(0,%f)-=(0,%f)\n", N,mm1[j],1.96*ecart/(sqrt(Draws)),1.96*ecart/(sqrt(Draws)));
        ecart=0.0;
        }
	//fprintf(fic,"%f %f %f\n",m,m-1.96*ecart/(sqrt(Draws)),m+1.96*ecart/(sqrt(Draws)));


	fclose(fic);
	fclose(fic3);
	fclose(fic4);
	/*********************************************/
    sprintf(str, "%d_", N);

    fic=fopen(nom_fic9,"a");

	ecart=0.0;
	m=0.0;
	float mMin=0.0;
	float mMax=0.0;
	for (i=0;i<Draws;i++) {
		m=m+muMin[i]/muMax[i];
		mMin=muMin[i]+mMin;
		mMax=mMax+muMax[i];
	}
	m=m/(float)Draws;
	mMin=mMin/(float)Draws;
	mMax=mMax/(float)Draws;

	for(i=0;i<Draws;i++) ecart=ecart+(float)(muMin[i]/muMax[i]-m)*(muMin[i]/muMax[i]-m);
	ecart=sqrt(ecart/(float)(Draws));
	//fprintf(fic,"%f %f %f\n",m,m-1.96*ecart/(sqrt(Draws)),m+1.96*ecart/(sqrt(Draws)));
    fprintf(fic,"(%d,%f)+=(0,%f)-=(0,%f)\n", N,m,1.96*ecart/(sqrt(Draws)),1.96*ecart/(sqrt(Draws)));
	fclose(fic);
	/*****************************************************/
	/*****************************************************/


}


/**
sorts an array in ascending order
*/

int * sort( float *max, int size)
{
    int i,j;
    float a;
    for (i = 0; i < size; ++i)
        {
            for (j = i + 1; j < size; ++j)
            {
                if (max[i] > max[j])
                {
                    a =  max[i];
                    max[i] = max[j];
                    max[j] = a;
                }
            }
        }

    return max;
}


/**
checks if the arm is one of the M best arms
returns its index in the top arms if yes, and
-1 otherwise
*/
int isOftheBest(int n, float* max, int index, int size)
{
    int i;
    for ( i=0; i < size; i++)
    {
        if (Player[n].B[index].mu >= max[i])
            return i;
    }

    return -1;
}


/** finds the collision rate
*/
float getCollisionRate(int n)
{
    return 1-pow(1-Player[n].pr/Card(Player[n].A),N-1)*(1+(N-1)*Player[n].pr/Card(Player[n].A));

}



/** tests if all players found the M best arms or not
*/
int allPlayersFinish()
{   int i;

    for (i=0;i<N;i++)
        if( Card(Player[i].A) > M)
            return 0;

    return 1;
}


/**finds if a player played each arms at least p times
*/
int leastPlayed(int n, int p)
{
    for(int i=0;i<K;i++)
        if(Player[n].B[i].tk<p)
            return 0;
   // printf("least played\n");
    return 1;
}

int leastPlayed_(int n, int p)
{
    int sum=0;
    for(int i=0;i<K;i++)
        if(Player[n].A[i]==-1 || Player[n].A[i]==0)
            sum++;
    if(sum>=p) return 1;
   // printf("least played\n");
    return 1;
}

/**returns the absolute value of a float variable
*/
float absolute(float x)
{
    if(x<0)
        return -1*x;
    return x;
}
/*****************************************************************************/

/**initializes the actions
*/
void InitAction()
{
	int i;

	for (i=0;i<K;i++) Action[i]=1;
	}

/**initializes the structure bandit
*/
void InitBandit(struct Bandit *B)
{
	int i;
	for (i=0;i<K;i++) {
			B[i].mu=0.0;
			B[i].tk=0;
			B[i].B=RAND_MAX;
			B[i].UCB=900.0;
			B[i].LCB=-900.0;
			B[i].var=0.0; //variance
			B[i].reward=(float*)malloc(sizeof(float)*1);
			B[i].notified=0;
		}

}

/**initiates the players
*/
void InitPlayers()
{
	int i,j;

	for (i=0;i<N;i++) {

			InitBandit(Player[i].B);
			for (j=0;j<K;j++) {Player[i].A[j]=1;}
			Player[i].k=0;
			Player[i].NbAction=K;
			Player[i].t=0;

			Player[i].ack_ActiveRate=0;
			Player[i].finishEstimating=0;
			Player[i].estimationsSent=0;
			Player[i].Arm=(float*)malloc(sizeof(float)*K);
			Player[i].nbPlayArms=(int*)malloc(sizeof(int)*K);
			Player[i].bestM=(int*)malloc(sizeof(int)*M);
			Player[i].armsSeq=(int*)malloc(sizeof(int)*tao);
			Player[i].rewardsSeq=(float*)malloc(sizeof(float)*tao);
			Player[i].avgSeq=(float*)malloc(sizeof(float)*K);
			for(int k=0;k<K;k++)
                {Player[i].nbPlayArms[k]=-1;
                Player[i].Arm[k]=0.0;}
            playersRewards[i]=0.0;
            Player[i].lastPlayedArm=selectChannel();


	}
}

/**returns 0 if at least one arm is never played by player n
*/
int testArms(int n)
{
    for(int k=0;k<K;k++)
        if(Player[n].nbPlayArms[k]==-1)return 0;
    return 1;
}

/**selects a channel among the K ones between 0 and K-1*/
int selectChannel()
{
    int n = rand() % K ;
    return n;
}

/**returns the index of the fastest player
*/
int fastPl()
{
    int max=0;
    for (int n=0;n<N;n++)
        if(Player[max].pr<Player[n].pr)
            max=n;
    return max;
}

/**finds the player of the least active rate*/
int slowPl()
{
    int min=0;
    for (int n=0;n<N;n++)
        if(Player[min].pr>Player[n].pr)
            min=n;
    return min;
}

/**finds the absolute value of a float
*/
float aps(float value)
{
    if(value<0)
        return -1*value;
    return value;
}

/**finds the value of epsilon2
*/
void find_epsilon2()
{
    float den=0.0;
    int index=slowPl(); //player having the lowest active rate
    int index1=fastPl();
    float value1;
    float value2;

    for(int i=0;i<N;i++)
        den=den+Player[i].pr;

    epsilon2=(epsilon-den)/K;
    epsilon2=0.1;
    printf("new_epsilon2=%f\n",epsilon2);
}

/**initiates the number of plays each palyers should play
*/
void initialize_T_k()
{
    float sum=0.0;
    float prod=1.0;
    for(int n=0;n<N;n++) {sum=sum+Player[n].pr; }
    for(int n=0;n<N;n++)
        {   for(int n1=0;n1<N;n1++) if(n1!=n)prod=prod*(float)(1.0-Player[n1].pr/K);
            Player[n].T_k= (int) ceil(Player[n].pr* (float)log(2*K/delta)/(2*pow(epsilon2,2)*sum*pow(prod,2)));
            prod=1.0;
        }

}

/**returns 1 if the players successfully send their active rates
*/
int activeRatesKnown()
{
    for(int n=0;n<N;n++)
         if(activeRates[n]!=Player[n].pr) return 0;
    return 1;
}

/**returns 1 if player n finishes its estimations
*/
int playerFinishEstimating(int n)
{
    if(activeRatesKnown()==0) return 0;
    for(int k=0;k<K;k++)
        if(Player[n].B[k].tk<Player[n].T_k)
            return 0;
    return 1;
}

/**player n plays an arm in round robin
*/
int PlayRoundRobin (int n)
{
    if(Player[n].lastPlayedArm==K-1) Player[n].lastPlayedArm= 0;
    else Player[n].lastPlayedArm = Player[n].lastPlayedArm+1;

    return Player[n].lastPlayedArm;
}

/**returns 1 if all players finish their estimation
*/
int finishEstimating()
{
    for (int n=0;n<N;n++)
        if(playerFinishEstimating(n)==0) return 0;
    return 1;
}

/**returns 1 if all players play each arm the required number of times
*/
int testFinishRequiredNb()
{
    for(int n=0;n<N;n++)
        for(int k=0;k<K;k++)
            if(Player[n].B[k].tk<Player[n].T_k) return 0;
    return 1;
}

/**returns 1 if all players successfully sent their estimation
*/
int allisDone()
{
    for (int n=0;n<N;n++)
        if(Player[n].estimationsSent<1) return 0;
    return 1;
}

/**prints the players that have not finished estimating
*/
void leftPlayers()
{
    for(int n=0;n<N;n++)
        if(playerFinishEstimating(n)==0) printf("\t%d__%f\n",n,Player[n].pr);
}

/**finds the collision rate of player n
*/
float collisionRate(int n)
{
    float prod=1.0;
    for(int pl=0;pl<N;pl++)
        if(pl!=n) prod=prod*(1-Player[pl].pr/K);

    return prod;
}

/**calculates the final estimation of the arms
*/
void findFinalEstimation()
{
    float sum1,sum2;
    for(int k=0;k<K;k++)
        {sum1=0.0;
         sum2=0.0;
         for(int n=0; n<N;n++)
            if(Player[n].estimationsSent>=1)
                {sum1=sum1+estimations[n][k]*Player[n].nbPlayArms[k];
                 sum2=sum2+Player[n].nbPlayArms[k];
                }
         finalEstimation[k]=sum1/sum2;
        }
}

/**initializes the active rates of the players
*/
void initializeActiveRates()
{
    // In order to have the same players' distribution for all the experiments
    // we choose the following deterministic way
    p1=(1-exp(log(1-col)/(1280-1)))*10;
    pN=p1/4;
    p1=(2*p1-pN);
    printf("pN=%f\n",pN);
    float sump=0.0;
    printf("p1=%f\n",p1);
	int n;
    float x=(p1-pN)/(N-1);
    float y=pN;
	for (n=0;n<N;n++) {
		Player[n].p=y;
		Player[n].pr=y;
		sump=sump+Player[n].p;
		y=y+x;
	}
    printf("pN=%f\n",Player[0].pr);
    printf("p1=%f\n",Player[N-1].pr);
    printf("sump=%f\n",sump);

}

/**finds the expected collision rate
*/
float expectedCol(int k)
{
    float prd=1.0;
    for(int n=0;n<N;n++)
        if(Player[n].armToPlay==k)
            prd=prd*(1.0-Player[n].pr);
    return 1.0-prd;
}

/**returns the expected fairness level
*/
float expectedFair(int minP, int maxP)
{
    if(exploit==1 || exploit ==2)
    {float min=1.0;
    float max=0.0;
    int minpl=0;
    int maxpl=0;

    for(int n=0;n<N;n++)
    {
        float prd=1.0;
        for(int n1=0;n1<N;n1++)
            if(n1!=n && Player[n].armToPlay==Player[n1].armToPlay) prd=prd*(1-Player[n1].pr);


        if( prd*Arm[Player[n].armToPlay] < min) {min=prd*Arm[Player[n].armToPlay];minpl=n;}
        if( prd*Arm[Player[n].armToPlay] > max) {max=prd*Arm[Player[n].armToPlay];maxpl=n;}
        if(n==minP) printf("\nexpected mu=%d-->%f\n\n",minP,prd*Arm[Player[n].armToPlay]);
        if(n==maxP) printf("\nexpected mu=%d-->%f\n\n",maxP,prd*Arm[Player[n].armToPlay]);
    }

    printf("pl%d.p=%f, pl%d.p=%f\n",minpl,Player[minpl].pr,maxpl,Player[maxpl].pr );
    printf("pl%d played=%d/%f, and pl%d played=%d/%f\n", minpl, Player[minpl].t, Player[minpl].pr*T,maxpl, Player[maxpl].t, Player[maxpl].pr*T );
    printf("\nexpected min_mu=%d-->%f, expected max_mu =%d-->%f\n\n",minpl,min,maxpl,max);

    return min/max;}

    return 0.0;
}

/*float commCost1(int x)
{
    return 0.0;
}*/

/**returns the expected rewards
*/
float expReward()
{
    float sum=0.0;
    float prod=1.0;

    for(int n=0;n<N;n++)
        {for(int n1=0;n1<N;n1++)
            if(Player[n].armToPlay==Player[n1].armToPlay && n!= n1) prod=prod*(1.0-Player[n1].pr);
        sum=sum+Player[n].pr*Arm[Player[n].armToPlay]*prod;
        prod=1.0;
        }
    return sum;
}

/**retruns the expected pdr
*/
float expPDR()
{
    float sum=0.0;
    float prod=1.0;
    float sump=0.0;
    for(int n=0;n<N;n++) sump=sump+Player[n].pr;

    for(int n=0;n<N;n++)
        {for(int n1=0;n1<N;n1++)
            if(Player[n].armToPlay==Player[n1].armToPlay && n!= n1) prod=prod*(1.0-Player[n1].pr);
        sum=sum+Player[n].pr*Arm[Player[n].armToPlay]*prod;
        prod=1.0;
        }
    return sum/sump;
}


/**returns the expected succe'ss rate
*/
float expectedSuccessRate(int n)
{
    float prod1=1.0;
    for(int p=0;p<N;p++)
        if(p!=n)prod1=prod1*(1-Player[p].pr/K);
    return prod1;

}

/**initiates the settings when playing the collaborative exploration
*/
void initializeCollabExpl()
{
    InitServer();
    InitPlayers();
    initializeActiveRates();
    InitAction();
    find_epsilon2();
    initialize_T_k();
    for (int i=0;i<N;i++) activeRates[i]=0.0;
}

/**returns 1 if enough players send their estimations
*/
int enoughEstimations()
{
    int sum=0;
    int sumP=0;
    int sum2=0;
    for (int k=0;k<K;k++)
        {for(int n=0;n<N;n++)
            if(Player[n].estimationsSent>=1) {sum=sum+Player[n].B[k].tk; sumP=sumP+1;}
         if(sum < (float) log(2/delta)/(2*pow(epsilon2,2))) return 0;
        }
    printf("players voting are %d/%d\n", sumP/K,N);


    return 1;
}
/*****************SELFISH Exploration*********************/

/**retruns 1 if player n finishes estimating
*/
int selfishPlayerFinishEstimating(int n)
{
    for(int k=0;k<K;k++)
        if(Player[n].B[k].tk<Player[n].T_k)
            return 0;
    return 1;
}

/**returns 1 if all playuers finish estimpating*/
int SelfishfinishEstimating()
{
    for (int n=0;n<N;n++)
        if(selfishPlayerFinishEstimating(n)==0) return 0;
    return 1;
}

/**calculates the number of plays each player should do
*/
void initialize_SelfishT_k()
{
    float prod=1.0;

    for(int n=0;n<N;n++)
    {for(int n1=0;n1<N;n1++) if(n1!=n)prod=prod*(float)(1.0-Player[n1].pr/K);
    Player[n].T_k=(int) ceil(log(2*K/delta)/(2*pow(epsilon2,2)*pow(prod,2)));
    prod=1.0;
    }
}

/**initiates the settings when playiong the selfish exploration
*/
void initializeSelfishExpl()
{
    InitServer();
    InitPlayers();
    initializeActiveRates();
    InitAction();
    find_epsilon2();
    initialize_SelfishT_k();
}
/****************************************************/

/**retruns 1 if the most frequent player finishes estimating
*/
int ForcedFinishEstimating()
{
    for (int k=0;k<K;k++)
        if(Player[N-1].B[k].tk<Player[N-1].T_k) return 0;
    return 1;
}
/***************************UCB1******************/

/**updates the ucb of all arms of player n at time t
*/
void updateUCB1 (int n, int t)
{
    for(int k=0;k<K;k++)
        Player[n].B[k].UCB=sqrt(2*log(Player[n].t)/(Player[n].B[k].tk));
}

/**retruns the arm with the highest UCB for player n
*/
int playArm_UCB (int n)
{
    int max=0;

    for(int k=0;k<K;k++)
    {

        if(Player[n].B[k].mu+Player[n].B[k].UCB > Player[n].B[max].mu+Player[n].B[max].UCB) max=k;}
    return max;
}

/**retruns 1 if player n played each arm at least once
*/
int finish(int n)
{
    for(int k=0;k<K;k++)
        if(Player[n].B[k].tk<1) return 0;
    return 1;
}

/***********************Play best arms**************/

/**finds the M best arms
*/
void findM_best()

{

    M_best=(int*)malloc(sizeof(int)*M);

    for(int i=0;i<M;i++)
        {M_best[i]=K-1-i;
        printf("M_best[%d]=%d\n",i,M_best[i]);}

}

/**returns an arm uniformly selected from the
M arms
*/
int playM_bestUniformly()
{
    int n = rand() % M ;
    return M_best[n];
}

/**update the ucb of the M best arms
*/
void updateM_UCB1 (int n, int t)
{
    for(int k=0;k<M;k++)
        Player[n].B[M_best[k]].UCB=sqrt(log(Player[n].t)/(2*Player[n].B[M_best[k]].tk));
}

/**play the arm with the highest ucb within the M best
*/
int playArm_UCB_M (int n)
{
    int max=0;

    for(int k=0;k<M;k++)
        if(Player[n].B[M_best[k]].mu+Player[n].B[M_best[k]].UCB > Player[n].B[M_best[max]].mu+Player[n].B[M_best[max]].UCB) max=k;
    return M_best[max];
}

/**retruns 1 if player n played each of the M best arms at least once
*/
int finish_M(int n)
{
    for(int k=0;k<M;k++)
        if(Player[n].B[M_best[k]].tk<1) return 0;
    return 1;
}
/**************************************************************/
/**sort players according to their active rates
*/
int* sortActivePlayers(int nb, int* array )
{
    float* sorted=(float*)malloc(sizeof(float)*nb);
    int* sortedPlayers=(float*)malloc(sizeof(int)*nb);
    for(int i=0;i<nb;i++)
        {sorted[i]=Player[array[i]].pr;
        sortedPlayers[i]=array[i];}

    int i,j,b;
    float a;
    for (i = 0; i < nb; ++i)
        {
            for (j = i + 1; j < nb; ++j)
            {
                if (sorted[i] < sorted[j])
                {
                    a =  sorted[i];
                    b = sortedPlayers[i];

                    sorted[i] = sorted[j];
                    sortedPlayers[i]=sortedPlayers[j];

                    sorted[j] = a;
                    sortedPlayers[j]=b;
                }
            }
        }
    return sortedPlayers;

}
/***************************************************************/

/**returns the list of indexes of the arms of the greatest UCB index (mu+ucb) of player n*/
void find_bestM(int n)

{
   float* sortedArms=(float*)malloc(sizeof(float)*K);
   int* sortedIndexes=(int*)malloc(sizeof(int)*K);

   for(int i=0;i<K;i++)
        {sortedArms[i]=Player[n].Arm[i];
        sortedIndexes[i]=i;}

    int i,j,b;
    float a;
    for (i = 0; i < K; ++i)
        {
            for (j = i + 1; j < K; ++j)
            {
                if (sortedArms[i] < sortedArms[j])
                {
                    a =  sortedArms[i];
                    b = sortedIndexes[i];

                    sortedArms[i] = sortedArms[j];
                    sortedIndexes[i]=sortedIndexes[j];

                    sortedArms[j] = a;
                    sortedIndexes[j]=b;
                }
            }
        }


    int * best_M=(int*)malloc(sizeof(int)*M);
    for(int i=0;i<M;i++)
        best_M[i]=sortedIndexes[i];

    Player[n].bestM=best_M;
}

/**returns 1 if arm k is one of the M best arms of player n
*/
int isMbest(int n, int k)
{
    for(int i=0;i<M;i++)
        if(k==Player[n].bestM[i])return 1;
    return 0;
}

/**returns an arm uniformly chosen within the M best arms of player n
*/
int playMbest(int n)
{
    int r=rand()%M;
    printf("r=%d,playMbest=%d\n",r,Player[n].bestM[r%M]);
    return Player[n].bestM[r%M];
}
/***************************************EXP3*********************************/

/**finds the p parameter of EXp3 algorithm
*/
void p_exp3(int n)
{
    float sum=0;
    for(int i=0;i<K;i++)
        sum=sum+wEXP[n][i];
    for(int i=0;i<K;i++)
        pEXP[n][i]=(1-gamma)*wEXP[n][i]/sum+ gamma/K;
}

/**draw an arm according to Exp3 algorithm
*/
int drawArm_exp3(int n)
{
    float sum=0;
    float sum1=0;
    for(int i=0;i<K;i++)
        sum=sum+wEXP[n][i];

    float numy=((float)rand()/(float)(RAND_MAX)) * sum;
    for(int i=0;i<K;i++)
        {
            sum1=sum1+wEXP[n][i];
            if(numy<=sum1)
                return i;
        }

}

/**updates the wExp parameter of EXP3 algorithm
*/
void update_wEXP(int n ,float y)
{
    for (int i=0;i<K;i++)
        if(i==Player[i].k) wEXP[n][i]=wEXP[n][i]*exp(gamma*y/pEXP[n][i]/K);

}
