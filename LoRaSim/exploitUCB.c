#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <math.h>
#include <float.h>
#include <dos.h>
#include "type.h"
#define PI 3.14159265

/**nodes using UCB to select sf and tp
*/
void exploitUCB()
{
    printf("************************_____________UCB  ___________****************************\n");


    while(nbPkts<T)
    {
        if((nbPkts) % (T/TimeDisplay)==0 ) printf("%d packets are already sent\n",nbPkts);
        for(int n=0;n<N;n++)
        {
            if(node[n].pr >= RAND_R(1.0))
            {
                node[n].isPlaying=1;
                if(n<N1)
                    {if(backgroundN!=5) node[n].arm =selectArm(n);
                    if(backgroundN==5)
                        {if(node[n].last_sinr[19]!=-1.0 )
                            ADR(n);
                         node[n].arm=node[n].ind_sf;
                        }
                    }

                ///play UCB
                if(n>=N1)
                {
                    if(node[n].nb_pkts<K)
                        node[n].arm = play_roundRobin(n);//playing all arms in the first phase
                    else node[n].arm=recommendArm_UCB (n);

                    node[n].B[node[n].arm].tk=node[n].B[node[n].arm].tk+1;
                    playArm(n,node[n].arm);
                    arms[node[n].ind_sf][(int) node[n].tx/3]++;
                    global_plays++;
                    nPlaysbyarm[node[n].arm]++;
                    global_energy=global_energy+energy(n);
                }

                node[n].nb_plays++;

                float rn=0.0;
                while(rn==0) rn=RAND_R(1);
                node[n].rayleigh=-1.0*log(rn);
                node[n].PL=log2lin(pathLoss(n)+P.shadowing*randn());
                node[n].RSSI=log2lin(node[n].tx)*node[n].rayleigh/node[n].PL;
                node[n].energy=node[n].energy+energy(n);

                node[n].nb_sf[node[n].ind_sf]++;
                nb_sf[node[n].ind_sf]++;
            }
            else node[n].isPlaying=0;
        }


        ///Collisions Study
        for(int n=0;n<N;n++)
            {
            if(node[n].isPlaying)
                {
                int y=Tr_success(n);
                int k=node[n].arm;

                ///background nodes following ADR
                    if(n<N1 && backgroundN==5)
                    {
                        updateSINR(n);
                        if(y==1)
                            {node[n].last_sinr[node[n].indx]=node[n].SINR;
                            node[n].indx++;
                            node[n].pr=node[n].p;
                            node[n].cons_coll=0;
                            }
                        if(y==0) node[n].cons_coll++;
                        if(node[n].cons_coll==retransmit)
                            node[n].cons_coll=0;
                        if(node[n].cons_coll==3 || node[n].cons_coll==5 || node[n].cons_coll==7)
                            {node[n].ind_sf++;
                            if(node[n].ind_sf>5)node[n].ind_sf=5;
                            }
                    }

                if(y==0&& n>=N1)
                    {
                    node[n].cons_coll++;
                    node[n].pr=node[n].p*8;
                    }

                if( (y==1 ||  node[n].cons_coll==retransmit)&& n>=N1)
                    {node[n].pr=node[n].p;
                    nbPkts++;
                    }

                node[n].nb_pkts++;
                float rw=getReward(n,y==0,node[n].cons_coll+1);

                node[n].sum_rewards=node[n].sum_rewards+rw;
                node[n].B[k].avg_reward= (float)rw/(float)node[n].B[k].tk+(float)(node[n].B[k].tk-1)/(float)node[n].B[k].tk*node[n].B[k].avg_reward;
                updateUCB1 (n);

                if(n>=N1)
                    {global_rewards=global_rewards+rw;
                    rewardAvgs[node[n].ind_sf][(int) node[n].tx/3]=rewardAvgs[node[n].ind_sf][(int) node[n].tx/3]+rw;
                    rewardPerArm[k]=rewardPerArm[k]+rw;
                    }

                if(y==1&& n>=N1)
                    {
                    global_success++;
                    node[n].nb_success++;
                    node[n].cons_coll=0;
                    }

                if(node[n].cons_coll==retransmit&& n>=N1)
                    {
                    lostPkts[dr][k]++;
                    totally_lost[dr]++;
                    losArms[node[n].ind_sf][(int) node[n].tx/3]++;
                    node[n].cons_coll=0;

                    }
                node[n].B[k].mu=(float)y/(float)node[n].B[k].tk+(float)(node[n].B[k].tk-1)/(float)node[n].B[k].tk*node[n].B[k].mu;
                }
            }

    slotEnd();
    slot++;
 }

printf("energy=%f, lost packets=%d, received packets=%d, pkts sent=%d,los=%d, col=%d, all plays=%d, pdr=%f\n",global_energy,totally_lost[dr],global_success,nbPkts,loss[dr], intrnalColl[dr],global_plays,(float)global_success/global_plays);

}







